<!DOCTYPE html><head><meta charset="UTF-8"><title>Linear Finite Volume Design Decisions in MOOSE | Zapdos</title><link href="../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../css/devel_moose.css" type="text/css" rel="stylesheet"></link><link href="../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><link href="../css/civet_moose.css" type="text/css" rel="stylesheet"></link><link href="../contrib/katex/katex.min.css" type="text/css" rel="stylesheet"></link><link href="../css/katex_moose.css" type="text/css" rel="stylesheet"></link><link href="../css/zapdos.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../contrib/jquery/jquery.min.js"></script><script type="text/javascript" src="../contrib/katex/katex.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="../index.html" class="left moose-logo hide-on-med-and-down" id="home-button">Zapdos</a><a href="https://github.com/shannon-lab/zapdos" class="right"><img src="../media/framework/github-logo.png" class="github-mark"></img><img src="../media/framework/github-mark.png" class="github-logo"></img></a><ul class="right hide-on-med-and-down"><li><a href="#!" class="dropdown-trigger" data-target="a2c57cea-4e86-4202-8261-e8012eca83c4" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="7f312c9c-f880-4493-9efa-817a19b00508" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="ffc83b9a-221c-4252-bbc8-d4829fec477b" data-constrainWidth="false">Help<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../citing.html">Citing</a></li></ul><a href="#" class="sidenav-trigger" data-target="086a9544-12ab-4fae-bb13-06c82fc39122"><i class="material-icons">menu</i></a><ul class="sidenav" id="086a9544-12ab-4fae-bb13-06c82fc39122"><li><a href="#!" class="dropdown-trigger" data-target="3196e577-0f2b-4fe3-89a7-1fb50a88e737" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="2f1c1e37-9cb7-4e40-8c1c-4bfdb74e147e" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="0375c102-3539-472c-bebf-90a58fe479b4" data-constrainWidth="false">Help<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../citing.html">Citing</a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div><ul class="dropdown-content" id="a2c57cea-4e86-4202-8261-e8012eca83c4"><li><a href="../getting_started/installation.html">Installation</a></li><li><a href="../getting_started/using_zapdos.html">Using Zapdos</a></li><li><a href="../getting_started/zapdos_meshing.html">Generating Meshes</a></li><li><a href="../tutorial/index.html">Tutorial Slides</a></li></ul><ul class="dropdown-content" id="7f312c9c-f880-4493-9efa-817a19b00508"><li><a href="../syntax/zapdos_only.html">Zapdos Input Syntax</a></li><li><a href="../syntax/index.html">Complete Code Syntax</a></li><li><a href="https://mooseframework.inl.gov/docs/doxygen/moose/classes.html">MOOSE Doxygen</a></li><li><a href="https://mooseframework.inl.gov/docs/doxygen/libmesh/classes.html">libMesh Doxygen</a></li><li><a href="../a-to-z.html">Zapdos A to Z Index</a></li><li><a href="../examples/crane_examples.html">CRANE Examples</a></li><li><a href="../development/contributing.html">Contributing Guidelines</a></li><li><a href="../development/code_standards.html">Code Standards</a></li><li><a href="../publications.html">List of Publications</a></li></ul><ul class="dropdown-content" id="ffc83b9a-221c-4252-bbc8-d4829fec477b"><li><a href="https://github.com/shannon-lab/zapdos/discussions">Zapdos Discussions Forum</a></li><li><a href="../development/zapdos_developer_info.html">Zapdos Developer Information</a></li><li><a href="https://github.com/idaholab/moose/discussions">MOOSE Discussions Forum</a></li><li><a href="https://mooseframework.inl.gov/">MOOSE Homepage</a></li><li><a href="../development/moose_developer_info.html">MOOSE Developer Information</a></li></ul><ul class="dropdown-content" id="3196e577-0f2b-4fe3-89a7-1fb50a88e737"><li><a href="../getting_started/installation.html">Installation</a></li><li><a href="../getting_started/using_zapdos.html">Using Zapdos</a></li><li><a href="../getting_started/zapdos_meshing.html">Generating Meshes</a></li><li><a href="../tutorial/index.html">Tutorial Slides</a></li></ul><ul class="dropdown-content" id="2f1c1e37-9cb7-4e40-8c1c-4bfdb74e147e"><li><a href="../syntax/zapdos_only.html">Zapdos Input Syntax</a></li><li><a href="../syntax/index.html">Complete Code Syntax</a></li><li><a href="https://mooseframework.inl.gov/docs/doxygen/moose/classes.html">MOOSE Doxygen</a></li><li><a href="https://mooseframework.inl.gov/docs/doxygen/libmesh/classes.html">libMesh Doxygen</a></li><li><a href="../a-to-z.html">Zapdos A to Z Index</a></li><li><a href="../examples/crane_examples.html">CRANE Examples</a></li><li><a href="../development/contributing.html">Contributing Guidelines</a></li><li><a href="../development/code_standards.html">Code Standards</a></li><li><a href="../publications.html">List of Publications</a></li></ul><ul class="dropdown-content" id="0375c102-3539-472c-bebf-90a58fe479b4"><li><a href="https://github.com/shannon-lab/zapdos/discussions">Zapdos Discussions Forum</a></li><li><a href="../development/zapdos_developer_info.html">Zapdos Developer Information</a></li><li><a href="https://github.com/idaholab/moose/discussions">MOOSE Discussions Forum</a></li><li><a href="https://mooseframework.inl.gov/">MOOSE Homepage</a></li><li><a href="../development/moose_developer_info.html">MOOSE Developer Information</a></li></ul></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="row"><div class="col l12"><div class="input-field"><input type_="text" onkeyup="mooseSearch()" placeholder="/index.md" id="moose-search-box"></input></div></div><div><div class="col s12" id="moose-search-results"></div></div></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="col hide-on-med-and-down l12"><nav class="breadcrumb-nav"><div class="nav-wrapper"><a href="." class="breadcrumb">finite_volumes</a><a href="#" class="breadcrumb">linear_fv_design</a></div></nav></div></div><div class="row"><div class="moose-content col s12 m12 l10"><section id="56cfccc1-65c6-4142-bfd6-877c4925c06a" data-section-level="1" data-section-text="Linear Finite Volume Design Decisions in MOOSE"><h1 id="linear-finite-volume-design-decisions-in-moose">Linear Finite Volume Design Decisions in MOOSE</h1><p>The main motivation for introducing a new approach for finite volume system assembly is that many fluid dynamics solvers use a Picard-style velocity-pressure coupling and the routines designed for computing Residuals and Jacobians for Newton solves involve additional costs that can considerably slow down a Picard solve which may require orders of magnitude more iterations for convergence.</p><p>To distinguish from the classical parts of MOOSE that solve nonlinear equations implicity using the Newton (or quasi-Newton) method, the new linear class names include a <code>Linear</code> sub-string denoting that they contribute to a [linear system containing a matrix of coefficients and a right hand side](LinearSystem.md) instead of a Jacobian and a residual.</p><section class="scrollspy" id="8e6bba9a-ba36-474c-b764-e372e25463eb" data-section-level="2" data-section-text="Design Choices for Finite Volume Linear System Assembly"><h2 id="design-choices-for-finite-volume-linear-system-assembly">Design Choices for Finite Volume Linear System Assembly</h2><ul class="browser-default"><li><p>We assume a Picard-style iteration where the <a href="../source/systems/LinearSystem.html">system matrix and right hand side</a> are assembled using the previous solution vector. </p></li><li><p>We rely on the <code>LinearSystem</code> class in MOOSE which is a wrapper around the <code>LinearImplicit</code> system class of <code>libMesh</code>. The corresponding kernels will directly contribute to the system matrix and right hand side owned by the <code>LinearSystem</code> class. </p></li><li><p>We try to keep the matrix as sparse as possible so every term that requires an extended stencil is treated explicitly. The assumption is that if we already use a Picard-style solve this will increase the total number of iterations a little bit, but for large runs the increased number of iterations will be offset by faster linear solves and assembly times.</p></li></ul></section><section class="scrollspy" id="baa808a5-1839-49fc-843d-7bbd21a40d24" data-section-level="2" data-section-text="Linear FV Variables"><h2 id="linear-fv-variables">Linear FV Variables</h2><p>Linear variables are designed only to contribute to linear systems. The following list summarizes the main differences compared to <a href="../source/variables/MooseVariableFV.html">finite volume variables</a> that contribute to a Newton system:</p><ul class="browser-default"><li><p>The linear variable does not support automatic differentiation. </p></li><li><p>The gradient computation is not located within the variable, it is populated in an external loop. This will be further discussed below. </p></li><li><p>The data members that enable quadrature-based evaluation of the variable are only used when interfacing with other MOOSE systems such as <a href="../source/userobjects/UserObject.html">UserObjects</a>, <a href="../source/auxkernels/AuxKernel.html">AuxKernels</a> or <a href="../source/postprocessors/Postprocessor.html">Postprocessors</a>. These data members are not used during the solve. For this reason, the preferred avenue for interfacing with these variables should be the <a href="../syntax/Functors/index.html">functor system</a>.</p></li></ul></section><section class="scrollspy" id="cd6b882f-d106-482d-9fc9-901d2cde6bd1" data-section-level="2" data-section-text="Linear FV Kernels"><h2 id="linear-fv-kernels">Linear FV Kernels</h2><p>To add contributions to the system matrix and right hand side to a linear system, a new system has been created which corresponds to the <code>[LinearFVKernels]</code> block in the input file. These kernels add contributions to the system matrix and right hand side of a linear system directly.</p><section id="386e27ec-d890-4364-b4b4-1eacbe6adab5" data-section-level="3" data-section-text="Flux Kernels"><h3 id="flux-kernels">Flux Kernels</h3><p>Similarly to the nonlinear approach with the Newton system, we often encounter terms in the partial differential equations which contain face fluxes in the discretized form. To represent such terms, we added a <code>LinearFVFluxKernel</code> base class which should be used for inheritance to populate matrices and right hand sides through a face loop. Good examples are the advection and diffusion terms in most transport equations. Within these functions the following functions need to be overridden:</p><ul class="browser-default"><li><p><code>computeElemMatrixContribution</code> which computes the matrix contributions of the face to the degree of freedom corresponding to the element side of the face. </p></li><li><p><code>computeNeighborMatrixContribution</code> which computes the matrix contributions of the face to the degree of freedom corresponding to the neighbor side of the face. </p></li><li><p><code>computeElemRightHandSideContribution</code> which computes the right hand side contributions of the face to the degree of freedom corresponding to the element side of the face. </p></li><li><p><code>computeNeighborRightHandSideContribution</code> which computes the right hand side contributions of the face to the degree of freedom corresponding to the neighbor side of the face. </p></li><li><p><code>computeBoundaryMatrixContribution</code> which computes the matrix contributions of a boundary face to the degree of freedom corresponding to the adjacent element. </p></li><li><p><code>computeBoundaryRHSContribution</code> which computes the right hand side contributions of a boundary face to the degree of freedom corresponding to the adjacent element.</p></li></ul></section><section id="b6c232b3-fefd-4dde-b05f-6d8f35feef30" data-section-level="3" data-section-text="Elemental Kernels"><h3 id="elemental-kernels">Elemental Kernels</h3><p>For volumetric effects, an element-based evaluation is necessary. Good examples are external source terms or reaction terms in the partial differential equations. To manage the contributions of these terms to the linear system, a <code>LinearFVElementalKernel</code> base class has been added which can be used for inheritance. The derived kernels need to override the following functions:</p><ul class="browser-default"><li><p><code>computeMatrixContribution</code> which computes the matrix contributions to the degree of freedom corresponding to the element. </p></li><li><p><code>computeRightHandSideContribution</code> which computes the right hand side contributions to the degree of freedom corresponding to the element.</p></li></ul><p>The population of the system matrix and right hand side with face terms (from flux kernels) is done in a face loop: <code>ComputeLinearFVFaceThread</code>.</p><p>On the other hand, the population of the system matrix and right hand side with element-based volumetric terms is done in an element loop: <code>ComputeLinearFVElementalThread</code>.</p></section></section><section class="scrollspy" id="1ed66746-0929-46ff-a750-60fc03ac6151" data-section-level="2" data-section-text="Gradient Computation"><h2 id="gradient-computation">Gradient Computation</h2><p>Considering that the linear finite volume system is used in a Picard-style iteration, terms that need cell gradients are lagged. Treating gradient-based terms explicitly results in faster linear solves due to the matrix containing fewer entries. Such terms include:</p><ul class="browser-default"><li><p>The linear terms in the extrapolated boundary conditions. </p></li><li><p>The nonorthogonal correctors in the surface normal gradient computation.</p></li></ul><p>The explicit treatment of these terms allows us to keep only one ghosted layer (of elements shared between processes) in parallel simulations, minimizing the linear solve time and parallel communication time over an iteration. The setbacks of this design choice are:</p><ul class="browser-default"><li><p>We need corrector iterations to resolve extrapolated boundary conditions and nonorthogonal correctors. This means that even linear systems may need to be solved multiple times to get a converged solution. </p></li><li><p>It may increase the number of iterations needed to resolve nonlinearities.</p></li></ul></section><section class="scrollspy" id="3b0ebbfb-9cd7-4395-abb2-81d6861bdbe9" data-section-level="2" data-section-text="Boundary Conditions"><h2 id="boundary-conditions">Boundary Conditions</h2><p>A significant difference compared to other systems in MOOSE is the way boundary conditions are enforced. Even though the user is still required to define the boundary conditions in the <code>[LinearFVBCs]</code> block, these boundary conditions are not executed on their own; instead they are used within <code>LinearFVFluxKernel</code>-s, through the following two functions:</p><ul class="browser-default"><li><p><code>computeBoundaryMatrixContribution</code> which computes the matrix contributions of a boundary face to the degree of freedom corresponding to the adjacent element. </p></li><li><p><code>computeBoundaryRHSContribution</code> which computes the right hand side contributions of a boundary face to the degree of freedom corresponding to the adjacent element.</p></li></ul><p>To create a new boundary condition the following functions need to be overridden:</p><ul class="browser-default"><li><p><code>computeBoundaryValue</code> computes the boundary value of the field. </p></li><li><p><code>computBoundaryNormalGradient</code> computes the normal gradient of the variable on this boundary. </p></li><li><p><code>computeBoundaryValueMatrixContribution</code> computes the matrix contribution that would come from the boundary value of the field, extensively used within advection kernels. For example, on an outflow boundary in an advection problem, without using linear extrapolation, one can use the cell value as an approximation for the boundary value: <span class="moose-katex-inline-equation" id="moose-equation-a4c960a3-b240-4c33-9a9e-d98d8b867ac4"><script>var element = document.getElementById("moose-equation-a4c960a3-b240-4c33-9a9e-d98d8b867ac4");katex.render("u_b = u_C", element, {displayMode:false,throwOnError:false});</script></span>. In this case, we can treat the outflow term implicitly by adding a <span class="moose-katex-inline-equation" id="moose-equation-baac0de8-caa7-4992-95dc-0b6d6ac8e659"><script>var element = document.getElementById("moose-equation-baac0de8-caa7-4992-95dc-0b6d6ac8e659");katex.render("\\vec{v} \\cdot \\vec{n} |S_b|", element, {displayMode:false,throwOnError:false});</script></span> term to the matrix which comes from <span class="moose-katex-inline-equation" id="moose-equation-032cdf48-e139-427a-91f3-d689a9592b34"><script>var element = document.getElementById("moose-equation-032cdf48-e139-427a-91f3-d689a9592b34");katex.render("\\vec{v} \\cdot \\vec{n} u_C |S_b|", element, {displayMode:false,throwOnError:false});</script></span> outward flux term. This function will return <span class="moose-katex-inline-equation" id="moose-equation-ccee2ffa-0778-48fa-ab1c-10432e553bd6"><script>var element = document.getElementById("moose-equation-ccee2ffa-0778-48fa-ab1c-10432e553bd6");katex.render("1", element, {displayMode:false,throwOnError:false});</script></span> (as it is just the cell value) and the <span class="moose-katex-inline-equation" id="moose-equation-0a55f2dd-74cb-4dbd-a828-f0dc6e00984d"><script>var element = document.getElementById("moose-equation-0a55f2dd-74cb-4dbd-a828-f0dc6e00984d");katex.render("\\vec{v} \\cdot \\vec{n} |S_b|", element, {displayMode:false,throwOnError:false});</script></span> multipliers are added in the advection kernel. </p></li><li><p><code>computeBoundaryValueRHSContribution</code> computes the right hand side contributions for terms that need the boundary value of the field, extensively used within advection kernels. Using the same example as above, by employing an extrapolation to the boundary face to determine the boundary value, we get the following expression: <span class="moose-katex-inline-equation" id="moose-equation-a3dcb930-eea8-4d08-9158-1ed9ddade1a0"><script>var element = document.getElementById("moose-equation-a3dcb930-eea8-4d08-9158-1ed9ddade1a0");katex.render("u_b = u_C+\\nabla u_C d_{Cf}", element, {displayMode:false,throwOnError:false});</script></span>, where <span class="moose-katex-inline-equation" id="moose-equation-30758f5a-8016-498d-8221-1f306dd6b5b1"><script>var element = document.getElementById("moose-equation-30758f5a-8016-498d-8221-1f306dd6b5b1");katex.render("d_{Cf}", element, {displayMode:false,throwOnError:false});</script></span> is the vector pointing to the face center from the cell center. In this case, besides the same matrix contribution as above, we need to add the following term to the right hand side: <span class="moose-katex-inline-equation" id="moose-equation-4dd61f17-bac9-4c11-9e54-a84f7c3677ae"><script>var element = document.getElementById("moose-equation-4dd61f17-bac9-4c11-9e54-a84f7c3677ae");katex.render("\\vec{v} \\cdot \\vec{n} \\nabla u_C d_{Cf} |S_b|", element, {displayMode:false,throwOnError:false});</script></span>. Therefore, this function returns <span class="moose-katex-inline-equation" id="moose-equation-06339ddf-98fd-43a8-9e53-d624d67d8029"><script>var element = document.getElementById("moose-equation-06339ddf-98fd-43a8-9e53-d624d67d8029");katex.render("\\nabla u_C d_{Cf}", element, {displayMode:false,throwOnError:false});</script></span> (as it is just the value contribution) and the other multipliers are added in the advection kernel. </p></li><li><p><code>computeBoundaryGradientMatrixContribution</code> computes the matrix contributions for terms that need the boundary gradient of the field, extensively used within diffusion kernels. Let us take a Dirichlet boundary condition and a diffusion kernel for example. The integral form of the diffusion term requires the computation of the surface normal gradient which can be approximated on an orthogonal grid as: <span class="moose-katex-block-equation"><span class="moose-katex-equation table-cell" id="moose-equation-f041475c-dc68-41a6-bdf1-cb285863d70b"></span><script>var element = document.getElementById("moose-equation-f041475c-dc68-41a6-bdf1-cb285863d70b");katex.render("  -\\int\\limits_{S_f}D\\nabla u \\vec{n}dS  \\approx -D\\frac{u_b - u_C}{|d_Cf|}|S_f|,", element, {displayMode:true,throwOnError:false});</script></span> which means that the term including <span class="moose-katex-inline-equation" id="moose-equation-d3c640ea-9232-4a44-b23e-d74f63158005"><script>var element = document.getElementById("moose-equation-d3c640ea-9232-4a44-b23e-d74f63158005");katex.render("u_C", element, {displayMode:false,throwOnError:false});</script></span> can go to the matrix of coefficients. Therefore, this function will return <span class="moose-katex-inline-equation" id="moose-equation-0888b47e-2080-4414-ac03-b055b7ca360b"><script>var element = document.getElementById("moose-equation-0888b47e-2080-4414-ac03-b055b7ca360b");katex.render("\\frac{1}{|d_Cf|}", element, {displayMode:false,throwOnError:false});</script></span> with additional multipliers added at the kernel level. </p></li><li><p><code>computeBoundaryGradientRHSContribution</code> computes the right hand side contributions for terms that need the boundary gradient of the field, extensively used within diffusion kernels. Continuing with the example above, we add the remaining part of the expression (<span class="moose-katex-inline-equation" id="moose-equation-a6514410-f04d-4039-906e-40f8dbd5f7b5"><script>var element = document.getElementById("moose-equation-a6514410-f04d-4039-906e-40f8dbd5f7b5");katex.render("-\\frac{u_b}{|d_Cf|}", element, {displayMode:false,throwOnError:false});</script></span>) with the opposite sign to the right hand side. The additional multipliers, e.g. the diffusion coefficient and the surface area, are factored in at the kernel level.</p></li></ul><p></p></section></section></div><div class="col hide-on-med-and-down l2"><div class="toc-wrapper pin-top"><ul class="section table-of-contents"><li><a href="#8e6bba9a-ba36-474c-b764-e372e25463eb" class="tooltipped" data-position="left" data-tooltip="Design Choices for Finite Volume Linear System Assembly">Design Choices for Finite Volume Linear System Assembly</a></li><li><a href="#baa808a5-1839-49fc-843d-7bbd21a40d24" class="tooltipped" data-position="left" data-tooltip="Linear FV Variables">Linear FV Variables</a></li><li><a href="#cd6b882f-d106-482d-9fc9-901d2cde6bd1" class="tooltipped" data-position="left" data-tooltip="Linear FV Kernels">Linear FV Kernels</a></li><li><a href="#1ed66746-0929-46ff-a750-60fc03ac6151" class="tooltipped" data-position="left" data-tooltip="Gradient Computation">Gradient Computation</a></li><li><a href="#3b0ebbfb-9cd7-4395-abb2-81d6861bdbe9" class="tooltipped" data-position="left" data-tooltip="Boundary Conditions">Boundary Conditions</a></li></ul></div></div></div></div></main></div></body><script type="text/javascript" src="../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../js/init.js"></script><script type="text/javascript" src="../js/navigation.js"></script><script type="text/javascript" src="../contrib/fuse/fuse.min.js"></script><script type="text/javascript" src="../js/search_index.js"></script><script type="text/javascript" src="../js/sqa_moose.js"></script>