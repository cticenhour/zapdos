<!DOCTYPE html><head><meta charset="UTF-8"><title>SakiyamaElectronDiffusionBC | Zapdos</title><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/devel_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/civet_moose.css" type="text/css" rel="stylesheet"></link><link href="../../contrib/katex/katex.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/katex_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/zapdos.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script><script type="text/javascript" src="../../contrib/katex/katex.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="../../index.html" class="left moose-logo hide-on-med-and-down" id="home-button">Zapdos</a><a href="https://github.com/shannon-lab/zapdos" class="right"><img src="../../media/framework/github-logo.png" class="github-mark"></img><img src="../../media/framework/github-mark.png" class="github-logo"></img></a><ul class="right hide-on-med-and-down"><li><a href="#!" class="dropdown-trigger" data-target="87ae37c1-e2cf-47bf-b2e8-f0707ab88968" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="37b64ab4-bbc8-4e20-a893-9346992ee0a1" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="14033444-94ec-4e0d-b883-2a8725935ff1" data-constrainWidth="false">Help<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../citing.html">Citing</a></li></ul><a href="#" class="sidenav-trigger" data-target="de576436-96d2-475d-8f3c-7d6722f8c8da"><i class="material-icons">menu</i></a><ul class="sidenav" id="de576436-96d2-475d-8f3c-7d6722f8c8da"><li><a href="#!" class="dropdown-trigger" data-target="1b8fc946-87c7-4167-a734-4001b21b5d9c" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="a0f76a1f-0f6b-4a73-8485-46e3ceaf89ea" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="ff61b56b-21ca-4b15-a8f6-71a5f248843c" data-constrainWidth="false">Help<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../citing.html">Citing</a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div><ul class="dropdown-content" id="87ae37c1-e2cf-47bf-b2e8-f0707ab88968"><li><a href="../../getting_started/installation.html">Installation</a></li><li><a href="../../getting_started/using_zapdos.html">Using Zapdos</a></li><li><a href="../../getting_started/zapdos_meshing.html">Generating Meshes</a></li><li><a href="../../tutorial/index.html">Tutorial Slides</a></li></ul><ul class="dropdown-content" id="37b64ab4-bbc8-4e20-a893-9346992ee0a1"><li><a href="../../syntax/zapdos_only.html">Zapdos Input Syntax</a></li><li><a href="../../syntax/index.html">Complete Code Syntax</a></li><li><a href="https://mooseframework.inl.gov/docs/doxygen/moose/classes.html">MOOSE Doxygen</a></li><li><a href="https://mooseframework.inl.gov/docs/doxygen/libmesh/classes.html">libMesh Doxygen</a></li><li><a href="../../a-to-z.html">Zapdos A to Z Index</a></li><li><a href="../../examples/crane_examples.html">CRANE Examples</a></li><li><a href="../../development/contributing.html">Contributing Guidelines</a></li><li><a href="../../development/code_standards.html">Code Standards</a></li><li><a href="../../publications.html">List of Publications</a></li></ul><ul class="dropdown-content" id="14033444-94ec-4e0d-b883-2a8725935ff1"><li><a href="https://github.com/shannon-lab/zapdos/discussions">Zapdos Discussions Forum</a></li><li><a href="../../development/zapdos_developer_info.html">Zapdos Developer Information</a></li><li><a href="https://github.com/idaholab/moose/discussions">MOOSE Discussions Forum</a></li><li><a href="https://mooseframework.inl.gov/">MOOSE Homepage</a></li><li><a href="../../development/moose_developer_info.html">MOOSE Developer Information</a></li></ul><ul class="dropdown-content" id="1b8fc946-87c7-4167-a734-4001b21b5d9c"><li><a href="../../getting_started/installation.html">Installation</a></li><li><a href="../../getting_started/using_zapdos.html">Using Zapdos</a></li><li><a href="../../getting_started/zapdos_meshing.html">Generating Meshes</a></li><li><a href="../../tutorial/index.html">Tutorial Slides</a></li></ul><ul class="dropdown-content" id="a0f76a1f-0f6b-4a73-8485-46e3ceaf89ea"><li><a href="../../syntax/zapdos_only.html">Zapdos Input Syntax</a></li><li><a href="../../syntax/index.html">Complete Code Syntax</a></li><li><a href="https://mooseframework.inl.gov/docs/doxygen/moose/classes.html">MOOSE Doxygen</a></li><li><a href="https://mooseframework.inl.gov/docs/doxygen/libmesh/classes.html">libMesh Doxygen</a></li><li><a href="../../a-to-z.html">Zapdos A to Z Index</a></li><li><a href="../../examples/crane_examples.html">CRANE Examples</a></li><li><a href="../../development/contributing.html">Contributing Guidelines</a></li><li><a href="../../development/code_standards.html">Code Standards</a></li><li><a href="../../publications.html">List of Publications</a></li></ul><ul class="dropdown-content" id="ff61b56b-21ca-4b15-a8f6-71a5f248843c"><li><a href="https://github.com/shannon-lab/zapdos/discussions">Zapdos Discussions Forum</a></li><li><a href="../../development/zapdos_developer_info.html">Zapdos Developer Information</a></li><li><a href="https://github.com/idaholab/moose/discussions">MOOSE Discussions Forum</a></li><li><a href="https://mooseframework.inl.gov/">MOOSE Homepage</a></li><li><a href="../../development/moose_developer_info.html">MOOSE Developer Information</a></li></ul></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="row"><div class="col l12"><div class="input-field"><input type_="text" onkeyup="mooseSearch()" placeholder="/index.md" id="moose-search-box"></input></div></div><div><div class="col s12" id="moose-search-results"></div></div></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="col hide-on-med-and-down l12"><nav class="breadcrumb-nav"><div class="nav-wrapper"><a href=".." class="breadcrumb">source</a><span class="breadcrumb">bcs</span><a href="#" class="breadcrumb">SakiyamaElectronDiffusionBC</a></div></nav></div></div><div class="row"><div class="moose-content col s12 m12 l10"><section id="36b61e58-7bb3-4c26-b58b-f75928431ed5" data-section-level="1" data-section-text="SakiyamaElectronDiffusionBC"><h1 id="sakiyamaelectrondiffusionbc">SakiyamaElectronDiffusionBC</h1><p>Kinetic electron boundary condition (Based on <a href="#sakiyama2006corona">Sakiyama and Graves (2006)</a>)</p><section class="scrollspy" id="9edc24a5-5fda-4f67-a3a6-fdb49b2cb02b" data-section-level="2" data-section-text="Overview"><h2 id="overview">Overview</h2><p><code>SakiyamaElectronDiffusionBC</code> is a thermal outflow boundary condition.</p><p>The thermal driven outflow is defined as</p><p><span class="moose-katex-block-equation"><span class="moose-katex-equation table-cell" id="moose-equation-282dff83-820c-4408-a548-7ff875ac0000"></span><script>var element = document.getElementById("moose-equation-282dff83-820c-4408-a548-7ff875ac0000");katex.render("\\Gamma_{e} \\cdot \\textbf{n} = \\frac{1}{4}\\sqrt{\\frac{8e}{\\pi m_{e}} \\frac{2}{3} \\frac{n_{\\varepsilon}}{n_{e}}}n_{e}", element, {displayMode:true,throwOnError:false});</script></span></p><p>Where <span class="moose-katex-inline-equation" id="moose-equation-427d654d-444a-4bc1-ade0-90926b7e4e7c"><script>var element = document.getElementById("moose-equation-427d654d-444a-4bc1-ade0-90926b7e4e7c");katex.render("\\Gamma_e \\cdot \\textbf{n}", element, {displayMode:false,throwOnError:false});</script></span> is the flux normal to the boundary, <span class="moose-katex-inline-equation" id="moose-equation-bd7d0e05-dfa7-4fe3-8beb-1141825902c6"><script>var element = document.getElementById("moose-equation-bd7d0e05-dfa7-4fe3-8beb-1141825902c6");katex.render("\\textbf{n}", element, {displayMode:false,throwOnError:false});</script></span> is the normal vector of the boundary, <span class="moose-katex-inline-equation" id="moose-equation-89bc90e7-d4b0-4acd-b2c6-bfb77ca72459"><script>var element = document.getElementById("moose-equation-89bc90e7-d4b0-4acd-b2c6-bfb77ca72459");katex.render("n_{e}", element, {displayMode:false,throwOnError:false});</script></span> is the electron density, <span class="moose-katex-inline-equation" id="moose-equation-dfab805b-6d1c-45ff-92ca-64d572940d20"><script>var element = document.getElementById("moose-equation-dfab805b-6d1c-45ff-92ca-64d572940d20");katex.render("e", element, {displayMode:false,throwOnError:false});</script></span> is the elementary charge, and <span class="moose-katex-inline-equation" id="moose-equation-c9d99600-0a0e-4e55-84b2-70dacd0bf7bc"><script>var element = document.getElementById("moose-equation-c9d99600-0a0e-4e55-84b2-70dacd0bf7bc");katex.render("n_{\\varepsilon}", element, {displayMode:false,throwOnError:false});</script></span> is the mean energy density. When converting the density to log form and applying a scaling factor of the mesh, the strong form for <code>SakiyamaElectronDiffusionBC</code> is defined as</p><p><span class="moose-katex-block-equation"><span class="moose-katex-equation table-cell" id="moose-equation-32860057-97ad-47b0-afec-f1e750e6e82a"></span><script>var element = document.getElementById("moose-equation-32860057-97ad-47b0-afec-f1e750e6e82a");katex.render("\\Gamma_{e} \\cdot \\textbf{n} = \\frac{1}{4}\\sqrt{\\frac{8e}{\\pi m_{e}} \\frac{2}{3} \\exp (N_{\\varepsilon} - N_{e})}\\exp(N_{e})", element, {displayMode:true,throwOnError:false});</script></span></p><p>Where <span class="moose-katex-inline-equation" id="moose-equation-f511c9cc-a0f7-4d82-9126-cb5337c91e5e"><script>var element = document.getElementById("moose-equation-f511c9cc-a0f7-4d82-9126-cb5337c91e5e");katex.render("N_{j}", element, {displayMode:false,throwOnError:false});</script></span> is the molar density of the species in log form.</p></section><section class="scrollspy" id="5cea46d1-7bcb-4e35-b555-0b1ebf852c37" data-section-level="2" data-section-text="Example Input File Syntax"><h2 id="example-input-file-syntax">Example Input File Syntax</h2><pre style="max-height:350px;"><code class="language-moose">[BCs&lt;&lt;&lt;{&quot;href&quot;: &quot;../../syntax/BCs/index.html&quot;}&gt;&gt;&gt;]
  [em_physical_diffusion]
    type = SakiyamaElectronDiffusionBC&lt;&lt;&lt;{&quot;description&quot;: &quot;Kinetic electron boundary condition (Based on [!cite](sakiyama2006corona))&quot;, &quot;href&quot;: &quot;SakiyamaElectronDiffusionBC.html&quot;}&gt;&gt;&gt;
    variable&lt;&lt;&lt;{&quot;description&quot;: &quot;The name of the variable that this residual object operates on&quot;}&gt;&gt;&gt; = em
    electron_energy&lt;&lt;&lt;{&quot;description&quot;: &quot;The mean electron energy density in log form&quot;}&gt;&gt;&gt; = mean_en
    boundary&lt;&lt;&lt;{&quot;description&quot;: &quot;The list of boundary IDs from the mesh where this object applies&quot;}&gt;&gt;&gt; = &#x27;Top_Electrode Bottom_Electrode Top_Insulator Bottom_Insulator Walls&#x27;
    position_units&lt;&lt;&lt;{&quot;description&quot;: &quot;Units of position.&quot;}&gt;&gt;&gt; = ${dom0Scale}
  []
[]</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#d27ee8d0-0955-4f1b-824b-840063cb7c84">(test/tests/DriftDiffusionAction/2D_RF_Plasma_actions.i)</a></section><section class="scrollspy" id="31af10a4-f7f6-4116-809e-c71e1418b9bf" data-section-level="2" data-section-text="Input Parameters"><h2 id="input-parameters">Input Parameters</h2><section id="29d96cde-0d33-4e57-9c35-733e32908a7a" data-section-level="3" data-section-text="Required Parameters" data-details-open="open"><details class="moose-section-content" open="open"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">boundary</span><span class="moose-parameter-header-description">The list of boundary IDs from the mesh where this object applies</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;BoundaryName&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The list of boundary IDs from the mesh where this object applies</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">electron_energy</span><span class="moose-parameter-header-description">The mean electron energy density in log form</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;VariableName&gt;</p><p class="moose-parameter-description-doc-unit"><span>Unit:</span>(no unit assumed)</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The mean electron energy density in log form</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">position_units</span><span class="moose-parameter-header-description">Units of position.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>double</p><p class="moose-parameter-description-doc-unit"><span>Unit:</span>(no unit assumed)</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Units of position.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">variable</span><span class="moose-parameter-header-description">The name of the variable that this residual object operates on</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>NonlinearVariableName</p><p class="moose-parameter-description-doc-unit"><span>Unit:</span>(no unit assumed)</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The name of the variable that this residual object operates on</p></div></li></ul><summary><h3 data-details-open="open"><span class="moose-section-icon"></span>Required Parameters</h3></summary></details></section><section id="bbc7c51a-db68-4f65-9aab-583399924655" data-section-level="3" data-section-text="Optional Parameters" data-details-open="open"><details class="moose-section-content" open="open"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">displacements</span><span class="moose-parameter-header-description">The displacements</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;VariableName&gt;</p><p class="moose-parameter-description-doc-unit"><span>Unit:</span>(no unit assumed)</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The displacements</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">matrix_only</span><span class="moose-parameter-header-default">False</span><span class="moose-parameter-header-description">Whether this object is only doing assembly to matrices (no vectors)</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Whether this object is only doing assembly to matrices (no vectors)</p></div></li></ul><summary><h3 data-details-open="open"><span class="moose-section-icon"></span>Optional Parameters</h3></summary></details></section><section id="d76247aa-2af7-4dc7-bf2b-946599713cbc" data-section-level="3" data-section-text="Contribution To Tagged Field Data Parameters" data-details-open="close"><details class="moose-section-content"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">absolute_value_vector_tags</span><span class="moose-parameter-header-description">The tags for the vectors this residual object should fill with the absolute value of the residual contribution</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;TagName&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The tags for the vectors this residual object should fill with the absolute value of the residual contribution</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">extra_matrix_tags</span><span class="moose-parameter-header-description">The extra tags for the matrices this Kernel should fill</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;TagName&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The extra tags for the matrices this Kernel should fill</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">extra_vector_tags</span><span class="moose-parameter-header-description">The extra tags for the vectors this Kernel should fill</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;TagName&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The extra tags for the vectors this Kernel should fill</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">matrix_tags</span><span class="moose-parameter-header-default">system</span><span class="moose-parameter-header-description">The tag for the matrices this Kernel should fill</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>system</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MultiMooseEnum</p><p class="moose-parameter-description-options"><span>Options:</span>nontime, system</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The tag for the matrices this Kernel should fill</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">vector_tags</span><span class="moose-parameter-header-default">nontime</span><span class="moose-parameter-header-description">The tag for the vectors this Kernel should fill</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>nontime</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MultiMooseEnum</p><p class="moose-parameter-description-options"><span>Options:</span>nontime, time</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The tag for the vectors this Kernel should fill</p></div></li></ul><summary><h3 data-details-open="close"><span class="moose-section-icon"></span>Contribution To Tagged Field Data Parameters</h3></summary></details></section><section id="31601efb-214c-4dc6-9419-db90bd8ec4e5" data-section-level="3" data-section-text="Advanced Parameters" data-details-open="close"><details class="moose-section-content"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">control_tags</span><span class="moose-parameter-header-description">Adds user-defined labels for accessing object parameters via control logic.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;std::string&gt;</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Adds user-defined labels for accessing object parameters via control logic.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">diag_save_in</span><span class="moose-parameter-header-description">The name of auxiliary variables to save this BC's diagonal jacobian contributions to.  Everything about that variable must match everything about this variable (the type, what blocks it's on, etc.)</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;AuxVariableName&gt;</p><p class="moose-parameter-description-doc-unit"><span>Unit:</span>(no unit assumed)</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The name of auxiliary variables to save this BC's diagonal jacobian contributions to.  Everything about that variable must match everything about this variable (the type, what blocks it's on, etc.)</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">enable</span><span class="moose-parameter-header-default">True</span><span class="moose-parameter-header-description">Set the enabled status of the MooseObject.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>True</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>Yes</p><p class="moose-parameter-description"><span>Description:</span>Set the enabled status of the MooseObject.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">implicit</span><span class="moose-parameter-header-default">True</span><span class="moose-parameter-header-description">Determines whether this object is calculated using an implicit or explicit form</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>True</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Determines whether this object is calculated using an implicit or explicit form</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">save_in</span><span class="moose-parameter-header-description">The name of auxiliary variables to save this BC's residual contributions to.  Everything about that variable must match everything about this variable (the type, what blocks it's on, etc.)</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>std::vector&lt;AuxVariableName&gt;</p><p class="moose-parameter-description-doc-unit"><span>Unit:</span>(no unit assumed)</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The name of auxiliary variables to save this BC's residual contributions to.  Everything about that variable must match everything about this variable (the type, what blocks it's on, etc.)</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">seed</span><span class="moose-parameter-header-default">0</span><span class="moose-parameter-header-description">The seed for the master random number generator</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>0</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>unsigned int</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>The seed for the master random number generator</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">skip_execution_outside_variable_domain</span><span class="moose-parameter-header-default">False</span><span class="moose-parameter-header-description">Whether to skip execution of this boundary condition when the variable it applies to is not defined on the boundary. This can facilitate setups with moving variable domains and fixed boundaries. Note that the FEProblem boundary-restricted integrity checks will also need to be turned off if using this option</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Whether to skip execution of this boundary condition when the variable it applies to is not defined on the boundary. This can facilitate setups with moving variable domains and fixed boundaries. Note that the FEProblem boundary-restricted integrity checks will also need to be turned off if using this option</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">use_displaced_mesh</span><span class="moose-parameter-header-default">False</span><span class="moose-parameter-header-description">Whether or not this object should use the displaced mesh for computation.  Note that in the case this is true but no displacements are provided in the Mesh block the undisplaced mesh will still be used.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>Whether or not this object should use the displaced mesh for computation.  Note that in the case this is true but no displacements are provided in the Mesh block the undisplaced mesh will still be used.</p></div></li></ul><summary><h3 data-details-open="close"><span class="moose-section-icon"></span>Advanced Parameters</h3></summary></details></section><section id="c5c56442-c083-4627-82c4-ce7f2e6fbb3d" data-section-level="3" data-section-text="Material Property Retrieval Parameters" data-details-open="close"><details class="moose-section-content"><ul class="collapsible" data-collapsible="expandable"><li><div class="collapsible-header"><span class="moose-parameter-name">prop_getter_suffix</span><span class="moose-parameter-header-description">An optional suffix parameter that can be appended to any attempt to retrieve/get material properties. The suffix will be prepended with a '_' character.</span></div><div class="collapsible-body"><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>MaterialPropertyName</p><p class="moose-parameter-description-doc-unit"><span>Unit:</span>(no unit assumed)</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>An optional suffix parameter that can be appended to any attempt to retrieve/get material properties. The suffix will be prepended with a '_' character.</p></div></li><li><div class="collapsible-header"><span class="moose-parameter-name">use_interpolated_state</span><span class="moose-parameter-header-default">False</span><span class="moose-parameter-header-description">For the old and older state use projected material properties interpolated at the quadrature points. To set up projection use the ProjectedStatefulMaterialStorageAction.</span></div><div class="collapsible-body"><p class="moose-parameter-description-default"><span>Default:</span>False</p><p class="moose-parameter-description-cpptype"><span>C++ Type:</span>bool</p><p class="moose-parameter-description-controllable"><span>Controllable:</span>No</p><p class="moose-parameter-description"><span>Description:</span>For the old and older state use projected material properties interpolated at the quadrature points. To set up projection use the ProjectedStatefulMaterialStorageAction.</p></div></li></ul><summary><h3 data-details-open="close"><span class="moose-section-icon"></span>Material Property Retrieval Parameters</h3></summary></details></section></section><section class="scrollspy" id="3181a6b0-f663-4e80-a79e-755ae6826887" data-section-level="2" data-section-text="Input Files"><h2 id="input-files">Input Files</h2><ul class="moose-list-inputs browser-default"><li><a class="moose-source-filename tooltipped modal-trigger" href="#02743611-605f-41ce-9d46-833e1711958a">(test/tests/DriftDiffusionAction/2D_RF_Plasma_actions.i)</a></li><li><a class="moose-source-filename tooltipped modal-trigger" href="#5074d543-26b3-4cf8-83cd-be716ab21b52">(test/tests/Conference_Syntax_Tests/Lymberopoulos_with_argon_metastables_2D_At100mTorr.i)</a></li><li><a class="moose-source-filename tooltipped modal-trigger" href="#9592669c-a524-4639-ae7a-289a65c91eb2">(test/tests/DriftDiffusionAction/2D_RF_Plasma_no_actions.i)</a></li><li><a class="moose-source-filename tooltipped modal-trigger" href="#14da64d1-59a1-496d-a8ea-b3803d86e73e">(test/tests/Lymberopoulos_rf_discharge/Lymberopoulos_with_argon_metastables_2D_At100mTorr_CoarseMesh.i)</a></li><li><a class="moose-source-filename tooltipped modal-trigger" href="#e62bc260-352a-44a3-8ce4-9e7abe6ee19f">(test/tests/mms/bcs/2D_ElectronBC.i)</a></li><li><a class="moose-source-filename tooltipped modal-trigger" href="#d7c93497-dfb8-4995-881d-45927b2600b6">(test/tests/mms/bcs/2D_ElectronBC_NegivateOutWardFacingEfield.i)</a></li><li><a class="moose-source-filename tooltipped modal-trigger" href="#4dcfa089-3e58-4186-aa53-25393a51d3ee">(tutorial/tutorial04-PressureVsTe/RF_Plasma_WithOut_Metastables-1Torr.i)</a></li><li><a class="moose-source-filename tooltipped modal-trigger" href="#d8ab1934-742c-4c96-8a7a-952c15e7277e">(test/tests/Conference_Syntax_Tests/Lymberopoulos_with_argon_metastables_2D_At1Torr.i)</a></li></ul></section><section class="scrollspy" id="05c996b4-89d8-46e0-8be4-7f0bcef9799f" data-section-level="2" data-section-text="References"><h2 id="references">References</h2><div class="moose-bibliography"><ol><li id="sakiyama2006corona">Y&nbsp;Sakiyama and David&nbsp;B Graves.
Corona-glow transition in the atmospheric pressure rf-excited plasma needle.
<em>Journal of Physics D: Applied Physics</em>, 39(16):3644, 2006.
<a href="https://doi.org/10.1088/0022-3727/39/16/018">doi:10.1088/0022-3727/39/16/018</a>.<a href="#9e229a76-5f7d-488c-83cf-49b753da79b1" class="modal-trigger moose-bibtex-modal" style="padding-left:10px;">[BibTeX]</a><div class="modal" id="9e229a76-5f7d-488c-83cf-49b753da79b1"><div class="modal-content"><pre style="line-height:1.25;"><code class="language-latex">@article{sakiyama2006corona,
    author = "Sakiyama, Y and Graves, David B",
    title = "Corona-glow transition in the atmospheric pressure RF-excited plasma needle",
    journal = "Journal of Physics D: Applied Physics",
    volume = "39",
    number = "16",
    pages = "3644",
    year = "2006",
    publisher = "IOP Publishing",
    doi = "10.1088/0022-3727/39/16/018"
}
</code></pre></div></div></li></ol></div></section></section><div class="moose-modal modal" id="d27ee8d0-0955-4f1b-824b-840063cb7c84"><div class="modal-content"><h4>(test/tests/DriftDiffusionAction/2D_RF_Plasma_actions.i)</h4><pre style="max-height:350px;"><code class="language-moose">dom0Scale = 25.4e-3

[GlobalParams]
  potential_units = V
  use_moles = true
[]

[Mesh]
  type = FileMesh
  file = &#x27;GEC_mesh_coarse.msh&#x27;
  coord_type = RZ
  rz_coord_axis = Y
[]

#Effective potentials and their kernels are not defined by the
#DriftDiffusionAction, but charged particles effective by
#this potential can by defined by the action.
[Variables]
  [potential_ion]
  []
[]

#Action the supplies the drift-diffusion equations
#This action also adds JouleHeating and the ChargeSourceMoles_KV Kernels
[DriftDiffusionAction]
  [Plasma]
    electrons = em
    secondary_charged_particles = Ar+
    Neutrals = Ar*
    mean_energy = mean_en
    field = potential
    eff_fields = potential_ion
    eff_fields_property_names = potential_ion_property
    Is_field_unique = true
    using_offset = false
    position_units = ${dom0Scale}
    Additional_Outputs = &#x27;ElectronTemperature Current EField&#x27;
  []
[]

#The Kernels supply the sources terms
[Kernels]
  #Net electron production from ionization
  [em_ionization]
    type = EEDFReactionLog
    variable = em
    electrons = em
    target = Ar
    mean_energy = mean_en
    reaction = &#x27;em + Ar -&gt; em + em + Ar+&#x27;
    coefficient = 1
  []
  #Net electron production from step-wise ionization
  [em_stepwise_ionization]
    type = EEDFReactionLog
    variable = em
    electrons = em
    target = Ar*
    mean_energy = mean_en
    reaction = &#x27;em + Ar* -&gt; em + em + Ar+&#x27;
    coefficient = 1
  []
  #Net electron production from metastable pooling
  [em_pooling]
    type = ReactionSecondOrderLog
    variable = em
    v = Ar*
    w = Ar*
    reaction = &#x27;Ar* + Ar* -&gt; Ar+ + Ar + em&#x27;
    coefficient = 1
  []

  #Net ion production from ionization
  [Ar+_ionization]
    type = EEDFReactionLog
    variable = Ar+
    electrons = em
    target = Ar
    mean_energy = mean_en
    reaction = &#x27;em + Ar -&gt; em + em + Ar+&#x27;
    coefficient = 1
  []
  #Net ion production from step-wise ionization
  [Ar+_stepwise_ionization]
    type = EEDFReactionLog
    variable = Ar+
    electrons = em
    target = Ar*
    mean_energy = mean_en
    reaction = &#x27;em + Ar* -&gt; em + em + Ar+&#x27;
    coefficient = 1
  []
  #Net ion production from metastable pooling
  [Ar+_pooling]
    type = ReactionSecondOrderLog
    variable = Ar+
    v = Ar*
    w = Ar*
    reaction = &#x27;Ar* + Ar* -&gt; Ar+ + Ar + em&#x27;
    coefficient = 1
  []

  #Net excited Argon production from excitation
  [Ar*_excitation]
    type = EEDFReactionLog
    variable = Ar*
    electrons = em
    target = Ar
    mean_energy = mean_en
    reaction = &#x27;em + Ar -&gt; em + Ar*&#x27;
    coefficient = 1
  []
  #Net excited Argon loss from step-wise ionization
  [Ar*_stepwise_ionization]
    type = EEDFReactionLog
    variable = Ar*
    electrons = em
    target = Ar*
    mean_energy = mean_en
    reaction = &#x27;em + Ar* -&gt; em + em + Ar+&#x27;
    coefficient = -1
  []
  #Net excited Argon loss from superelastic collisions
  [Ar*_collisions]
    type = EEDFReactionLog
    variable = Ar*
    electrons = em
    target = Ar*
    mean_energy = mean_en
    reaction = &#x27;em + Ar* -&gt; em + Ar&#x27;
    coefficient = -1
  []
  #Net excited Argon loss from quenching to resonant
  [Ar*_quenching]
    type = EEDFReactionLog
    variable = Ar*
    electrons = em
    target = Ar*
    mean_energy = mean_en
    reaction = &#x27;em + Ar* -&gt; em + Ar_r&#x27;
    coefficient = -1
  []
  #Net excited Argon loss from  metastable pooling
  [Ar*_pooling]
    type = ReactionSecondOrderLog
    variable = Ar*
    v = Ar*
    w = Ar*
    reaction = &#x27;Ar* + Ar* -&gt; Ar+ + Ar + em&#x27;
    coefficient = -2
    _v_eq_u = true
    _w_eq_u = true
  []
  #Net excited Argon loss from two-body quenching
  [Ar*_2B_quenching]
    type = ReactionSecondOrderLog
    variable = Ar*
    v = Ar*
    w = Ar
    reaction = &#x27;Ar* + Ar -&gt; Ar + Ar&#x27;
    coefficient = -1
    _v_eq_u = true
  []
  #Net excited Argon loss from three-body quenching
  [Ar*_3B_quenching]
    type = ReactionThirdOrderLog
    variable = Ar*
    v = Ar*
    w = Ar
    x = Ar
    reaction = &#x27;Ar* + Ar + Ar -&gt; Ar_2 + Ar&#x27;
    coefficient = -1
    _v_eq_u = true
  []

  #Energy loss from ionization
  [Ionization_Loss]
    type = EEDFEnergyLog
    variable = mean_en
    electrons = em
    target = Ar
    reaction = &#x27;em + Ar -&gt; em + em + Ar+&#x27;
    threshold_energy = -15.7
  []
  #Energy loss from excitation
  [Excitation_Loss]
    type = EEDFEnergyLog
    variable = mean_en
    electrons = em
    target = Ar
    reaction = &#x27;em + Ar -&gt; em + Ar*&#x27;
    threshold_energy = -11.56
  []
  #Energy loss from step-wise ionization
  [Stepwise_Ionization_Loss]
    type = EEDFEnergyLog
    variable = mean_en
    electrons = em
    target = Ar*
    reaction = &#x27;em + Ar* -&gt; em + em + Ar+&#x27;
    threshold_energy = -4.14
  []
  #Energy gain from superelastic collisions
  [Collisions_Loss]
    type = EEDFEnergyLog
    variable = mean_en
    electrons = em
    target = Ar*
    reaction = &#x27;em + Ar* -&gt; em + Ar&#x27;
    threshold_energy = 11.56
  []
  # Energy loss from elastic collisions
  [Elastic_loss]
    type = EEDFElasticLog
    variable = mean_en
    electrons = em
    target = Ar
    reaction = &#x27;em + Ar -&gt; em + Ar&#x27;
  []

  #Effective potential for the Ions
  [Ion_potential_time_deriv]
    type = TimeDerivative
    variable = potential_ion
  []
  [Ion_potential_reaction]
    type = ScaledReaction
    variable = potential_ion
    collision_freq = 1283370.875
  []
  [Ion_potential_coupled_force]
    type = CoupledForce
    variable = potential_ion
    v = potential
    coef = 1283370.875
  []
[]

[AuxVariables]
  [x_node]
  []

  [y_node]
  []

  [rho]
    order = CONSTANT
    family = MONOMIAL
  []

  [Ar]
  []

  [emRate]
    order = CONSTANT
    family = MONOMIAL
    block = &#x27;plasma&#x27;
  []
  [exRate]
    order = CONSTANT
    family = MONOMIAL
    block = &#x27;plasma&#x27;
  []
  [swRate]
    order = CONSTANT
    family = MONOMIAL
    block = &#x27;plasma&#x27;
  []
  [deexRate]
    order = CONSTANT
    family = MONOMIAL
    block = &#x27;plasma&#x27;
  []
  [quRate]
    order = CONSTANT
    family = MONOMIAL
    block = &#x27;plasma&#x27;
  []
  [poolRate]
    order = CONSTANT
    family = MONOMIAL
    block = &#x27;plasma&#x27;
  []
  [TwoBRate]
    order = CONSTANT
    family = MONOMIAL
    block = &#x27;plasma&#x27;
  []
  [ThreeBRate]
    order = CONSTANT
    family = MONOMIAL
    block = &#x27;plasma&#x27;
  []

[]

[AuxKernels]
  [emRate]
    type = ProcRateForRateCoeff
    variable = emRate
    v = em
    w = Ar
    reaction = &#x27;em + Ar -&gt; em + em + Ar+&#x27;
  []
  [exRate]
    type = ProcRateForRateCoeff
    variable = exRate
    v = em
    w = Ar*
    reaction = &#x27;em + Ar -&gt; em + Ar*&#x27;
  []
  [swRate]
    type = ProcRateForRateCoeff
    variable = swRate
    v = em
    w = Ar*
    reaction = &#x27;em + Ar* -&gt; em + em + Ar+&#x27;
  []
  [deexRate]
    type = ProcRateForRateCoeff
    variable = deexRate
    v = em
    w = Ar*
    reaction = &#x27;em + Ar* -&gt; em + Ar&#x27;
  []
  [quRate]
    type = ProcRateForRateCoeff
    variable = quRate
    v = em
    w = Ar*
    reaction = &#x27;em + Ar* -&gt; em + Ar_r&#x27;
  []
  [poolRate]
    type = ProcRateForRateCoeff
    variable = poolRate
    v = Ar*
    w = Ar*
    reaction = &#x27;Ar* + Ar* -&gt; Ar+ + Ar + em&#x27;
  []
  [TwoBRate]
    type = ProcRateForRateCoeff
    variable = TwoBRate
    v = Ar*
    w = Ar
    reaction = &#x27;Ar* + Ar -&gt; Ar + Ar&#x27;
  []
  [ThreeBRate]
    type = ProcRateForRateCoeffThreeBody
    variable = ThreeBRate
    v = Ar*
    w = Ar
    x = Ar
    reaction = &#x27;Ar* + Ar + Ar -&gt; Ar_2 + Ar&#x27;
  []

  [x_ng]
    type = Position
    variable = x_node
    component = 0
    position_units = ${dom0Scale}
  []

  [y_ng]
    type = Position
    variable = y_node
    component = 1
    position_units = ${dom0Scale}
  []

  [Ar_val]
    type = ConstantAux
    variable = Ar
    # value = 3.22e2
    value = -5.231208
    execute_on = INITIAL
  []
[]

[BCs]
  #Voltage Boundary Condition, same as in paper
  [potential_top_plate]
    type = FunctionDirichletBC
    variable = potential
    boundary = &#x27;Top_Electrode&#x27;
    function = potential_top_bc_func
    preset = false
  []
  [potential_bottom_plate]
    type = FunctionDirichletBC
    variable = potential
    boundary = &#x27;Bottom_Electrode&#x27;
    function = potential_bottom_bc_func
    preset = false
  []
  [potential_dirichlet_bottom_plate]
    type = DirichletBC
    variable = potential
    boundary = &#x27;Walls&#x27;
    value = 0
    preset = false
  []
  [potential_Dielectric]
    type = EconomouDielectricBC
    variable = potential
    boundary = &#x27;Top_Insulator Bottom_Insulator&#x27;
    electrons = em
    ions = Ar+
    ion_potentials = potential_ion
    electron_energy = mean_en
    dielectric_constant = 1.859382e-11
    thickness = 0.0127
    emission_coeffs = 0.01
    position_units = ${dom0Scale}
  []

  #New Boundary conditions for electons, same as in paper
  [em_physical_diffusion]
    type = SakiyamaElectronDiffusionBC
    variable = em
    electron_energy = mean_en
    boundary = &#x27;Top_Electrode Bottom_Electrode Top_Insulator Bottom_Insulator Walls&#x27;
    position_units = ${dom0Scale}
  []
  [em_Ar+_second_emissions]
    type = SakiyamaSecondaryElectronBC
    variable = em
    field_property_name = potential_ion_property
    ions = Ar+
    emission_coeffs = 0.01
    boundary = &#x27;Top_Electrode Bottom_Electrode Top_Insulator Bottom_Insulator Walls&#x27;
    position_units = ${dom0Scale}
  []

  #New Boundary conditions for ions, should be the same as in paper
  [Ar+_physical_advection]
    type = SakiyamaIonAdvectionBC
    variable = Ar+
    field_property_name = potential_ion_property
    boundary = &#x27;Top_Electrode Bottom_Electrode Top_Insulator Bottom_Insulator Walls&#x27;
    position_units = ${dom0Scale}
  []

  #New Boundary conditions for ions, should be the same as in paper
  #(except the metastables are not set to zero, since Zapdos uses log form)
  [Ar*_physical_diffusion]
    type = LogDensityDirichletBC
    variable = Ar*
    boundary = &#x27;Top_Electrode Bottom_Electrode Top_Insulator Bottom_Insulator Walls&#x27;
    value = 100
  []

  #New Boundary conditions for mean energy, should be the same as in paper
  [mean_en_physical_diffusion]
    type = SakiyamaEnergyDiffusionBC
    variable = mean_en
    electrons = em
    boundary = &#x27;Top_Electrode Bottom_Electrode Top_Insulator Bottom_Insulator Walls&#x27;
    position_units = ${dom0Scale}
  []
  [mean_en_Ar+_second_emissions]
    type = SakiyamaEnergySecondaryElectronBC
    variable = mean_en
    electrons = em
    ions = Ar+
    field_property_name = potential_ion_property
    Tse_equal_Te = true
    emission_coeffs = 0.01
    boundary = &#x27;Top_Electrode Bottom_Electrode Top_Insulator Bottom_Insulator Walls&#x27;
    position_units = ${dom0Scale}
  []

[]

[ICs]
  [em_ic]
    type = FunctionIC
    variable = em
    function = density_ic_func
  []
  [Ar+_ic]
    type = FunctionIC
    variable = Ar+
    function = density_ic_func
  []
  [Ar*_ic]
    type = FunctionIC
    variable = Ar*
    function = meta_density_ic_func
  []
  [mean_en_ic]
    type = FunctionIC
    variable = mean_en
    function = energy_density_ic_func
  []

  [potential_ic]
    type = FunctionIC
    variable = potential
    function = potential_ic_func
  []
[]

[Functions]
  [potential_top_bc_func]
    type = ParsedFunction
    expression = &#x27;50*sin(2*3.1415926*13.56e6*t)&#x27;
  []
  [potential_bottom_bc_func]
    type = ParsedFunction
    expression = &#x27;-50*sin(2*3.1415926*13.56e6*t)&#x27;
  []
  [potential_ic_func]
    type = ParsedFunction
    expression = 0
  []
  [density_ic_func]
    type = ParsedFunction
    expression = &#x27;log((1e14)/6.022e23)&#x27;
  []
  [meta_density_ic_func]
    type = ParsedFunction
    expression = &#x27;log((1e16)/6.022e23)&#x27;
  []
  [energy_density_ic_func]
    type = ParsedFunction
    expression = &#x27;log((3./2.) * 4) + log((1e14)/6.022e23)&#x27;
  []
[]

[Materials]
  [GasBasics]
    type = GasElectronMoments
    interp_trans_coeffs = true
    interp_elastic_coeff = false
    ramp_trans_coeffs = false
    user_p_gas = 133.322
    em = em
    mean_en = mean_en
    user_se_coeff = 0.00
    property_tables_file = Argon_reactions_paper_RateCoefficients/electron_moments.txt
  []
  [gas_species_0]
    type = ADHeavySpecies
    heavy_species_name = Ar+
    heavy_species_mass = 6.64e-26
    heavy_species_charge = 1.0
    mobility = 1.44409938
    diffusivity = 6.428571e-2
  []
  [gas_species_1]
    type = ADHeavySpecies
    heavy_species_name = Ar*
    heavy_species_mass = 6.64e-26
    heavy_species_charge = 0.0
    diffusivity = 7.515528e-2
  []
  [gas_species_2]
    type = ADHeavySpecies
    heavy_species_name = Ar
    heavy_species_mass = 6.64e-26
    heavy_species_charge = 0.0
  []
  [reaction_00]
    type = ZapdosEEDFRateConstant
    mean_energy = mean_en
    property_file = &#x27;Argon_reactions_paper_RateCoefficients/ar_elastic.txt&#x27;
    reaction = &#x27;em + Ar -&gt; em + Ar&#x27;
    electrons = em
  []
  [reaction_0]
    type = ZapdosEEDFRateConstant
    property_file = &#x27;Argon_reactions_paper_RateCoefficients/ar_excitation.txt&#x27;
    reaction = &#x27;em + Ar -&gt; em + Ar*&#x27;
    mean_energy = mean_en
    electrons = em
  []
  [reaction_1]
    type = ZapdosEEDFRateConstant
    property_file = &#x27;Argon_reactions_paper_RateCoefficients/ar_ionization.txt&#x27;
    reaction = &#x27;em + Ar -&gt; em + em + Ar+&#x27;
    mean_energy = mean_en
    electrons = em
  []
  [reaction_2]
    type = ZapdosEEDFRateConstant
    reaction = &#x27;em + Ar* -&gt; em + Ar&#x27;
    property_file = &#x27;Argon_reactions_paper_RateCoefficients/ar_deexcitation.txt&#x27;
    mean_energy = mean_en
    electrons = em
  []
  [reaction_3]
    type = ZapdosEEDFRateConstant
    reaction = &#x27;em + Ar* -&gt; em + em + Ar+&#x27;
    property_file = &#x27;Argon_reactions_paper_RateCoefficients/ar_excited_ionization.txt&#x27;
    mean_energy = mean_en
    electrons = em
  []
  [reaction_4]
    type = GenericRateConstant
    reaction = &#x27;em + Ar* -&gt; em + Ar_r&#x27;
    #reaction_rate_value = 2e-13
    reaction_rate_value = 1.2044e11
  []
  [reaction_5]
    type = GenericRateConstant
    reaction = &#x27;Ar* + Ar* -&gt; Ar+ + Ar + em&#x27;
    #reaction_rate_value = 6.2e-16
    reaction_rate_value = 373364000
  []
  [reaction_6]
    type = GenericRateConstant
    reaction = &#x27;Ar* + Ar -&gt; Ar + Ar&#x27;
    #reaction_rate_value = 3e-21
    reaction_rate_value = 1806.6
  []
  [reaction_7]
    type = GenericRateConstant
    reaction = &#x27;Ar* + Ar + Ar -&gt; Ar_2 + Ar&#x27;
    #reaction_rate_value = 1.1e-42
    reaction_rate_value = 398909.324
  []
[]

#New postprocessor that calculates the inverse of the plasma frequency
[Postprocessors]
  [InversePlasmaFreq]
    type = PlasmaFrequencyInverse
    variable = em
    use_moles = true
    execute_on = &#x27;INITIAL TIMESTEP_BEGIN&#x27;
  []
[]

[Preconditioning]
  active = &#x27;smp&#x27;
  [smp]
    type = SMP
    full = true
  []

  [fdp]
    type = FDP
    full = true
  []
[]

[Executioner]
  type = Transient
  #end_time = 7.4e-3
  end_time = 1e-7
  dtmax = 1e-9
  petsc_options = &#x27;-snes_converged_reason -snes_linesearch_monitor&#x27;
  solve_type = NEWTON
  petsc_options_iname = &#x27;-pc_type -pc_factor_shift_type -pc_factor_shift_amount -ksp_type -snes_linesearch_minlambda&#x27;
  petsc_options_value = &#x27;lu NONZERO 1.e-10 fgmres 1e-3&#x27;
  nl_rel_tol = 1e-12
  #nl_abs_tol = 7.6e-5
  dtmin = 1e-14
  l_max_its = 20

  #Time steps based on the inverse of the plasma frequency
  #[TimeSteppers]
  #  [Postprocessor]
  #    type = PostprocessorDT
  #    postprocessor = InversePlasmaFreq
  #    scale = 0.1
  #  []
  #[]
[]

[Outputs]
  file_base = &#x27;2D_RF_out&#x27;
  perf_graph = true
  [out]
    type = Exodus
  []
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="02743611-605f-41ce-9d46-833e1711958a"><div class="modal-content"><h4>(test/tests/DriftDiffusionAction/2D_RF_Plasma_actions.i)</h4><pre style="max-height:350px;"><code class="language-moose">dom0Scale = 25.4e-3

[GlobalParams]
  potential_units = V
  use_moles = true
[]

[Mesh]
  type = FileMesh
  file = &#x27;GEC_mesh_coarse.msh&#x27;
  coord_type = RZ
  rz_coord_axis = Y
[]

#Effective potentials and their kernels are not defined by the
#DriftDiffusionAction, but charged particles effective by
#this potential can by defined by the action.
[Variables]
  [potential_ion]
  []
[]

#Action the supplies the drift-diffusion equations
#This action also adds JouleHeating and the ChargeSourceMoles_KV Kernels
[DriftDiffusionAction]
  [Plasma]
    electrons = em
    secondary_charged_particles = Ar+
    Neutrals = Ar*
    mean_energy = mean_en
    field = potential
    eff_fields = potential_ion
    eff_fields_property_names = potential_ion_property
    Is_field_unique = true
    using_offset = false
    position_units = ${dom0Scale}
    Additional_Outputs = &#x27;ElectronTemperature Current EField&#x27;
  []
[]

#The Kernels supply the sources terms
[Kernels]
  #Net electron production from ionization
  [em_ionization]
    type = EEDFReactionLog
    variable = em
    electrons = em
    target = Ar
    mean_energy = mean_en
    reaction = &#x27;em + Ar -&gt; em + em + Ar+&#x27;
    coefficient = 1
  []
  #Net electron production from step-wise ionization
  [em_stepwise_ionization]
    type = EEDFReactionLog
    variable = em
    electrons = em
    target = Ar*
    mean_energy = mean_en
    reaction = &#x27;em + Ar* -&gt; em + em + Ar+&#x27;
    coefficient = 1
  []
  #Net electron production from metastable pooling
  [em_pooling]
    type = ReactionSecondOrderLog
    variable = em
    v = Ar*
    w = Ar*
    reaction = &#x27;Ar* + Ar* -&gt; Ar+ + Ar + em&#x27;
    coefficient = 1
  []

  #Net ion production from ionization
  [Ar+_ionization]
    type = EEDFReactionLog
    variable = Ar+
    electrons = em
    target = Ar
    mean_energy = mean_en
    reaction = &#x27;em + Ar -&gt; em + em + Ar+&#x27;
    coefficient = 1
  []
  #Net ion production from step-wise ionization
  [Ar+_stepwise_ionization]
    type = EEDFReactionLog
    variable = Ar+
    electrons = em
    target = Ar*
    mean_energy = mean_en
    reaction = &#x27;em + Ar* -&gt; em + em + Ar+&#x27;
    coefficient = 1
  []
  #Net ion production from metastable pooling
  [Ar+_pooling]
    type = ReactionSecondOrderLog
    variable = Ar+
    v = Ar*
    w = Ar*
    reaction = &#x27;Ar* + Ar* -&gt; Ar+ + Ar + em&#x27;
    coefficient = 1
  []

  #Net excited Argon production from excitation
  [Ar*_excitation]
    type = EEDFReactionLog
    variable = Ar*
    electrons = em
    target = Ar
    mean_energy = mean_en
    reaction = &#x27;em + Ar -&gt; em + Ar*&#x27;
    coefficient = 1
  []
  #Net excited Argon loss from step-wise ionization
  [Ar*_stepwise_ionization]
    type = EEDFReactionLog
    variable = Ar*
    electrons = em
    target = Ar*
    mean_energy = mean_en
    reaction = &#x27;em + Ar* -&gt; em + em + Ar+&#x27;
    coefficient = -1
  []
  #Net excited Argon loss from superelastic collisions
  [Ar*_collisions]
    type = EEDFReactionLog
    variable = Ar*
    electrons = em
    target = Ar*
    mean_energy = mean_en
    reaction = &#x27;em + Ar* -&gt; em + Ar&#x27;
    coefficient = -1
  []
  #Net excited Argon loss from quenching to resonant
  [Ar*_quenching]
    type = EEDFReactionLog
    variable = Ar*
    electrons = em
    target = Ar*
    mean_energy = mean_en
    reaction = &#x27;em + Ar* -&gt; em + Ar_r&#x27;
    coefficient = -1
  []
  #Net excited Argon loss from  metastable pooling
  [Ar*_pooling]
    type = ReactionSecondOrderLog
    variable = Ar*
    v = Ar*
    w = Ar*
    reaction = &#x27;Ar* + Ar* -&gt; Ar+ + Ar + em&#x27;
    coefficient = -2
    _v_eq_u = true
    _w_eq_u = true
  []
  #Net excited Argon loss from two-body quenching
  [Ar*_2B_quenching]
    type = ReactionSecondOrderLog
    variable = Ar*
    v = Ar*
    w = Ar
    reaction = &#x27;Ar* + Ar -&gt; Ar + Ar&#x27;
    coefficient = -1
    _v_eq_u = true
  []
  #Net excited Argon loss from three-body quenching
  [Ar*_3B_quenching]
    type = ReactionThirdOrderLog
    variable = Ar*
    v = Ar*
    w = Ar
    x = Ar
    reaction = &#x27;Ar* + Ar + Ar -&gt; Ar_2 + Ar&#x27;
    coefficient = -1
    _v_eq_u = true
  []

  #Energy loss from ionization
  [Ionization_Loss]
    type = EEDFEnergyLog
    variable = mean_en
    electrons = em
    target = Ar
    reaction = &#x27;em + Ar -&gt; em + em + Ar+&#x27;
    threshold_energy = -15.7
  []
  #Energy loss from excitation
  [Excitation_Loss]
    type = EEDFEnergyLog
    variable = mean_en
    electrons = em
    target = Ar
    reaction = &#x27;em + Ar -&gt; em + Ar*&#x27;
    threshold_energy = -11.56
  []
  #Energy loss from step-wise ionization
  [Stepwise_Ionization_Loss]
    type = EEDFEnergyLog
    variable = mean_en
    electrons = em
    target = Ar*
    reaction = &#x27;em + Ar* -&gt; em + em + Ar+&#x27;
    threshold_energy = -4.14
  []
  #Energy gain from superelastic collisions
  [Collisions_Loss]
    type = EEDFEnergyLog
    variable = mean_en
    electrons = em
    target = Ar*
    reaction = &#x27;em + Ar* -&gt; em + Ar&#x27;
    threshold_energy = 11.56
  []
  # Energy loss from elastic collisions
  [Elastic_loss]
    type = EEDFElasticLog
    variable = mean_en
    electrons = em
    target = Ar
    reaction = &#x27;em + Ar -&gt; em + Ar&#x27;
  []

  #Effective potential for the Ions
  [Ion_potential_time_deriv]
    type = TimeDerivative
    variable = potential_ion
  []
  [Ion_potential_reaction]
    type = ScaledReaction
    variable = potential_ion
    collision_freq = 1283370.875
  []
  [Ion_potential_coupled_force]
    type = CoupledForce
    variable = potential_ion
    v = potential
    coef = 1283370.875
  []
[]

[AuxVariables]
  [x_node]
  []

  [y_node]
  []

  [rho]
    order = CONSTANT
    family = MONOMIAL
  []

  [Ar]
  []

  [emRate]
    order = CONSTANT
    family = MONOMIAL
    block = &#x27;plasma&#x27;
  []
  [exRate]
    order = CONSTANT
    family = MONOMIAL
    block = &#x27;plasma&#x27;
  []
  [swRate]
    order = CONSTANT
    family = MONOMIAL
    block = &#x27;plasma&#x27;
  []
  [deexRate]
    order = CONSTANT
    family = MONOMIAL
    block = &#x27;plasma&#x27;
  []
  [quRate]
    order = CONSTANT
    family = MONOMIAL
    block = &#x27;plasma&#x27;
  []
  [poolRate]
    order = CONSTANT
    family = MONOMIAL
    block = &#x27;plasma&#x27;
  []
  [TwoBRate]
    order = CONSTANT
    family = MONOMIAL
    block = &#x27;plasma&#x27;
  []
  [ThreeBRate]
    order = CONSTANT
    family = MONOMIAL
    block = &#x27;plasma&#x27;
  []

[]

[AuxKernels]
  [emRate]
    type = ProcRateForRateCoeff
    variable = emRate
    v = em
    w = Ar
    reaction = &#x27;em + Ar -&gt; em + em + Ar+&#x27;
  []
  [exRate]
    type = ProcRateForRateCoeff
    variable = exRate
    v = em
    w = Ar*
    reaction = &#x27;em + Ar -&gt; em + Ar*&#x27;
  []
  [swRate]
    type = ProcRateForRateCoeff
    variable = swRate
    v = em
    w = Ar*
    reaction = &#x27;em + Ar* -&gt; em + em + Ar+&#x27;
  []
  [deexRate]
    type = ProcRateForRateCoeff
    variable = deexRate
    v = em
    w = Ar*
    reaction = &#x27;em + Ar* -&gt; em + Ar&#x27;
  []
  [quRate]
    type = ProcRateForRateCoeff
    variable = quRate
    v = em
    w = Ar*
    reaction = &#x27;em + Ar* -&gt; em + Ar_r&#x27;
  []
  [poolRate]
    type = ProcRateForRateCoeff
    variable = poolRate
    v = Ar*
    w = Ar*
    reaction = &#x27;Ar* + Ar* -&gt; Ar+ + Ar + em&#x27;
  []
  [TwoBRate]
    type = ProcRateForRateCoeff
    variable = TwoBRate
    v = Ar*
    w = Ar
    reaction = &#x27;Ar* + Ar -&gt; Ar + Ar&#x27;
  []
  [ThreeBRate]
    type = ProcRateForRateCoeffThreeBody
    variable = ThreeBRate
    v = Ar*
    w = Ar
    x = Ar
    reaction = &#x27;Ar* + Ar + Ar -&gt; Ar_2 + Ar&#x27;
  []

  [x_ng]
    type = Position
    variable = x_node
    component = 0
    position_units = ${dom0Scale}
  []

  [y_ng]
    type = Position
    variable = y_node
    component = 1
    position_units = ${dom0Scale}
  []

  [Ar_val]
    type = ConstantAux
    variable = Ar
    # value = 3.22e2
    value = -5.231208
    execute_on = INITIAL
  []
[]

[BCs]
  #Voltage Boundary Condition, same as in paper
  [potential_top_plate]
    type = FunctionDirichletBC
    variable = potential
    boundary = &#x27;Top_Electrode&#x27;
    function = potential_top_bc_func
    preset = false
  []
  [potential_bottom_plate]
    type = FunctionDirichletBC
    variable = potential
    boundary = &#x27;Bottom_Electrode&#x27;
    function = potential_bottom_bc_func
    preset = false
  []
  [potential_dirichlet_bottom_plate]
    type = DirichletBC
    variable = potential
    boundary = &#x27;Walls&#x27;
    value = 0
    preset = false
  []
  [potential_Dielectric]
    type = EconomouDielectricBC
    variable = potential
    boundary = &#x27;Top_Insulator Bottom_Insulator&#x27;
    electrons = em
    ions = Ar+
    ion_potentials = potential_ion
    electron_energy = mean_en
    dielectric_constant = 1.859382e-11
    thickness = 0.0127
    emission_coeffs = 0.01
    position_units = ${dom0Scale}
  []

  #New Boundary conditions for electons, same as in paper
  [em_physical_diffusion]
    type = SakiyamaElectronDiffusionBC
    variable = em
    electron_energy = mean_en
    boundary = &#x27;Top_Electrode Bottom_Electrode Top_Insulator Bottom_Insulator Walls&#x27;
    position_units = ${dom0Scale}
  []
  [em_Ar+_second_emissions]
    type = SakiyamaSecondaryElectronBC
    variable = em
    field_property_name = potential_ion_property
    ions = Ar+
    emission_coeffs = 0.01
    boundary = &#x27;Top_Electrode Bottom_Electrode Top_Insulator Bottom_Insulator Walls&#x27;
    position_units = ${dom0Scale}
  []

  #New Boundary conditions for ions, should be the same as in paper
  [Ar+_physical_advection]
    type = SakiyamaIonAdvectionBC
    variable = Ar+
    field_property_name = potential_ion_property
    boundary = &#x27;Top_Electrode Bottom_Electrode Top_Insulator Bottom_Insulator Walls&#x27;
    position_units = ${dom0Scale}
  []

  #New Boundary conditions for ions, should be the same as in paper
  #(except the metastables are not set to zero, since Zapdos uses log form)
  [Ar*_physical_diffusion]
    type = LogDensityDirichletBC
    variable = Ar*
    boundary = &#x27;Top_Electrode Bottom_Electrode Top_Insulator Bottom_Insulator Walls&#x27;
    value = 100
  []

  #New Boundary conditions for mean energy, should be the same as in paper
  [mean_en_physical_diffusion]
    type = SakiyamaEnergyDiffusionBC
    variable = mean_en
    electrons = em
    boundary = &#x27;Top_Electrode Bottom_Electrode Top_Insulator Bottom_Insulator Walls&#x27;
    position_units = ${dom0Scale}
  []
  [mean_en_Ar+_second_emissions]
    type = SakiyamaEnergySecondaryElectronBC
    variable = mean_en
    electrons = em
    ions = Ar+
    field_property_name = potential_ion_property
    Tse_equal_Te = true
    emission_coeffs = 0.01
    boundary = &#x27;Top_Electrode Bottom_Electrode Top_Insulator Bottom_Insulator Walls&#x27;
    position_units = ${dom0Scale}
  []

[]

[ICs]
  [em_ic]
    type = FunctionIC
    variable = em
    function = density_ic_func
  []
  [Ar+_ic]
    type = FunctionIC
    variable = Ar+
    function = density_ic_func
  []
  [Ar*_ic]
    type = FunctionIC
    variable = Ar*
    function = meta_density_ic_func
  []
  [mean_en_ic]
    type = FunctionIC
    variable = mean_en
    function = energy_density_ic_func
  []

  [potential_ic]
    type = FunctionIC
    variable = potential
    function = potential_ic_func
  []
[]

[Functions]
  [potential_top_bc_func]
    type = ParsedFunction
    expression = &#x27;50*sin(2*3.1415926*13.56e6*t)&#x27;
  []
  [potential_bottom_bc_func]
    type = ParsedFunction
    expression = &#x27;-50*sin(2*3.1415926*13.56e6*t)&#x27;
  []
  [potential_ic_func]
    type = ParsedFunction
    expression = 0
  []
  [density_ic_func]
    type = ParsedFunction
    expression = &#x27;log((1e14)/6.022e23)&#x27;
  []
  [meta_density_ic_func]
    type = ParsedFunction
    expression = &#x27;log((1e16)/6.022e23)&#x27;
  []
  [energy_density_ic_func]
    type = ParsedFunction
    expression = &#x27;log((3./2.) * 4) + log((1e14)/6.022e23)&#x27;
  []
[]

[Materials]
  [GasBasics]
    type = GasElectronMoments
    interp_trans_coeffs = true
    interp_elastic_coeff = false
    ramp_trans_coeffs = false
    user_p_gas = 133.322
    em = em
    mean_en = mean_en
    user_se_coeff = 0.00
    property_tables_file = Argon_reactions_paper_RateCoefficients/electron_moments.txt
  []
  [gas_species_0]
    type = ADHeavySpecies
    heavy_species_name = Ar+
    heavy_species_mass = 6.64e-26
    heavy_species_charge = 1.0
    mobility = 1.44409938
    diffusivity = 6.428571e-2
  []
  [gas_species_1]
    type = ADHeavySpecies
    heavy_species_name = Ar*
    heavy_species_mass = 6.64e-26
    heavy_species_charge = 0.0
    diffusivity = 7.515528e-2
  []
  [gas_species_2]
    type = ADHeavySpecies
    heavy_species_name = Ar
    heavy_species_mass = 6.64e-26
    heavy_species_charge = 0.0
  []
  [reaction_00]
    type = ZapdosEEDFRateConstant
    mean_energy = mean_en
    property_file = &#x27;Argon_reactions_paper_RateCoefficients/ar_elastic.txt&#x27;
    reaction = &#x27;em + Ar -&gt; em + Ar&#x27;
    electrons = em
  []
  [reaction_0]
    type = ZapdosEEDFRateConstant
    property_file = &#x27;Argon_reactions_paper_RateCoefficients/ar_excitation.txt&#x27;
    reaction = &#x27;em + Ar -&gt; em + Ar*&#x27;
    mean_energy = mean_en
    electrons = em
  []
  [reaction_1]
    type = ZapdosEEDFRateConstant
    property_file = &#x27;Argon_reactions_paper_RateCoefficients/ar_ionization.txt&#x27;
    reaction = &#x27;em + Ar -&gt; em + em + Ar+&#x27;
    mean_energy = mean_en
    electrons = em
  []
  [reaction_2]
    type = ZapdosEEDFRateConstant
    reaction = &#x27;em + Ar* -&gt; em + Ar&#x27;
    property_file = &#x27;Argon_reactions_paper_RateCoefficients/ar_deexcitation.txt&#x27;
    mean_energy = mean_en
    electrons = em
  []
  [reaction_3]
    type = ZapdosEEDFRateConstant
    reaction = &#x27;em + Ar* -&gt; em + em + Ar+&#x27;
    property_file = &#x27;Argon_reactions_paper_RateCoefficients/ar_excited_ionization.txt&#x27;
    mean_energy = mean_en
    electrons = em
  []
  [reaction_4]
    type = GenericRateConstant
    reaction = &#x27;em + Ar* -&gt; em + Ar_r&#x27;
    #reaction_rate_value = 2e-13
    reaction_rate_value = 1.2044e11
  []
  [reaction_5]
    type = GenericRateConstant
    reaction = &#x27;Ar* + Ar* -&gt; Ar+ + Ar + em&#x27;
    #reaction_rate_value = 6.2e-16
    reaction_rate_value = 373364000
  []
  [reaction_6]
    type = GenericRateConstant
    reaction = &#x27;Ar* + Ar -&gt; Ar + Ar&#x27;
    #reaction_rate_value = 3e-21
    reaction_rate_value = 1806.6
  []
  [reaction_7]
    type = GenericRateConstant
    reaction = &#x27;Ar* + Ar + Ar -&gt; Ar_2 + Ar&#x27;
    #reaction_rate_value = 1.1e-42
    reaction_rate_value = 398909.324
  []
[]

#New postprocessor that calculates the inverse of the plasma frequency
[Postprocessors]
  [InversePlasmaFreq]
    type = PlasmaFrequencyInverse
    variable = em
    use_moles = true
    execute_on = &#x27;INITIAL TIMESTEP_BEGIN&#x27;
  []
[]

[Preconditioning]
  active = &#x27;smp&#x27;
  [smp]
    type = SMP
    full = true
  []

  [fdp]
    type = FDP
    full = true
  []
[]

[Executioner]
  type = Transient
  #end_time = 7.4e-3
  end_time = 1e-7
  dtmax = 1e-9
  petsc_options = &#x27;-snes_converged_reason -snes_linesearch_monitor&#x27;
  solve_type = NEWTON
  petsc_options_iname = &#x27;-pc_type -pc_factor_shift_type -pc_factor_shift_amount -ksp_type -snes_linesearch_minlambda&#x27;
  petsc_options_value = &#x27;lu NONZERO 1.e-10 fgmres 1e-3&#x27;
  nl_rel_tol = 1e-12
  #nl_abs_tol = 7.6e-5
  dtmin = 1e-14
  l_max_its = 20

  #Time steps based on the inverse of the plasma frequency
  #[TimeSteppers]
  #  [Postprocessor]
  #    type = PostprocessorDT
  #    postprocessor = InversePlasmaFreq
  #    scale = 0.1
  #  []
  #[]
[]

[Outputs]
  file_base = &#x27;2D_RF_out&#x27;
  perf_graph = true
  [out]
    type = Exodus
  []
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="5074d543-26b3-4cf8-83cd-be716ab21b52"><div class="modal-content"><h4>(test/tests/Conference_Syntax_Tests/Lymberopoulos_with_argon_metastables_2D_At100mTorr.i)</h4><pre style="max-height:350px;"><code class="language-moose">dom0Scale = 25.4e-3

[GlobalParams]
  potential_units = V
  use_moles = true
[]

[Mesh]
  type = FileMesh
  file = &#x27;GEC_mesh.msh&#x27;
  coord_type = RZ
  rz_coord_axis = Y
[]

[Variables]
  [em]
  []

  [Ar+]
  []

  [Ar*]
  []

  [mean_en]
  []

  [potential]
  []

  [potential_ion]
  []
[]

[Kernels]
  #Electron Equations (Same as in paper)
  #Time Derivative term of electron
  [em_time_deriv]
    type = ElectronTimeDerivative
    variable = em
  []
  #Advection term of electron
  [em_advection]
    type = EFieldAdvection
    variable = em
    position_units = ${dom0Scale}
  []
  #Diffusion term of electrons
  [em_diffusion]
    type = CoeffDiffusion
    variable = em
    position_units = ${dom0Scale}
  []
  #Net electron production from ionization
  [em_ionization]
    type = EEDFReactionLog
    variable = em
    electrons = em
    target = Ar
    mean_energy = mean_en
    reaction = &#x27;em + Ar -&gt; em + em + Ar+&#x27;
    coefficient = 1
  []
  #Net electron production from step-wise ionization
  [em_stepwise_ionization]
    type = EEDFReactionLog
    variable = em
    electrons = em
    target = Ar*
    mean_energy = mean_en
    reaction = &#x27;em + Ar* -&gt; em + em + Ar+&#x27;
    coefficient = 1
  []
  #Net electron production from metastable pooling
  [em_pooling]
    type = ReactionSecondOrderLog
    variable = em
    v = Ar*
    w = Ar*
    reaction = &#x27;Ar* + Ar* -&gt; Ar+ + Ar + em&#x27;
    coefficient = 1
  []

  #Argon Ion Equations (Same as in paper)
  #Time Derivative term of the ions
  [Ar+_time_deriv]
    type = ElectronTimeDerivative
    variable = Ar+
  []
  #Advection term of ions
  [Ar+_advection]
    type = EFieldAdvection
    variable = Ar+
    position_units = ${dom0Scale}
  []
  [Ar+_diffusion]
    type = CoeffDiffusion
    variable = Ar+
    position_units = ${dom0Scale}
  []
  #Net ion production from ionization
  [Ar+_ionization]
    type = EEDFReactionLog
    variable = Ar+
    electrons = em
    target = Ar
    mean_energy = mean_en
    reaction = &#x27;em + Ar -&gt; em + em + Ar+&#x27;
    coefficient = 1
  []
  #Net ion production from step-wise ionization
  [Ar+_stepwise_ionization]
    type = EEDFReactionLog
    variable = Ar+
    electrons = em
    target = Ar*
    mean_energy = mean_en
    reaction = &#x27;em + Ar* -&gt; em + em + Ar+&#x27;
    coefficient = 1
  []
  #Net ion production from metastable pooling
  [Ar+_pooling]
    type = ReactionSecondOrderLog
    variable = Ar+
    v = Ar*
    w = Ar*
    reaction = &#x27;Ar* + Ar* -&gt; Ar+ + Ar + em&#x27;
    coefficient = 1
  []

  #Argon Excited Equations (Same as in paper)
  #Time Derivative term of excited Argon
  [Ar*_time_deriv]
    type = ElectronTimeDerivative
    variable = Ar*
  []
  #Diffusion term of excited Argon
  [Ar*_diffusion]
    type = CoeffDiffusion
    variable = Ar*
    position_units = ${dom0Scale}
  []
  #Net excited Argon production from excitation
  [Ar*_excitation]
    type = EEDFReactionLog
    variable = Ar*
    electrons = em
    target = Ar
    mean_energy = mean_en
    reaction = &#x27;em + Ar -&gt; em + Ar*&#x27;
    coefficient = 1
  []
  #Net excited Argon loss from step-wise ionization
  [Ar*_stepwise_ionization]
    type = EEDFReactionLog
    variable = Ar*
    electrons = em
    target = Ar*
    mean_energy = mean_en
    reaction = &#x27;em + Ar* -&gt; em + em + Ar+&#x27;
    coefficient = -1
  []
  #Net excited Argon loss from superelastic collisions
  [Ar*_collisions]
    type = EEDFReactionLog
    variable = Ar*
    electrons = em
    target = Ar*
    mean_energy = mean_en
    reaction = &#x27;em + Ar* -&gt; em + Ar&#x27;
    coefficient = -1
  []
  #Net excited Argon loss from quenching to resonant
  [Ar*_quenching]
    type = EEDFReactionLog
    variable = Ar*
    electrons = em
    target = Ar*
    mean_energy = mean_en
    reaction = &#x27;em + Ar* -&gt; em + Ar_r&#x27;
    coefficient = -1
  []
  #Net excited Argon loss from  metastable pooling
  [Ar*_pooling]
    type = ReactionSecondOrderLog
    variable = Ar*
    v = Ar*
    w = Ar*
    reaction = &#x27;Ar* + Ar* -&gt; Ar+ + Ar + em&#x27;
    coefficient = -2
    _v_eq_u = true
    _w_eq_u = true
  []
  #Net excited Argon loss from two-body quenching
  [Ar*_2B_quenching]
    type = ReactionSecondOrderLog
    variable = Ar*
    v = Ar*
    w = Ar
    reaction = &#x27;Ar* + Ar -&gt; Ar + Ar&#x27;
    coefficient = -1
    _v_eq_u = true
  []
  #Net excited Argon loss from three-body quenching
  [Ar*_3B_quenching]
    type = ReactionThirdOrderLog
    variable = Ar*
    v = Ar*
    w = Ar
    x = Ar
    reaction = &#x27;Ar* + Ar + Ar -&gt; Ar_2 + Ar&#x27;
    coefficient = -1
    _v_eq_u = true
  []

  #Voltage Equations (Same as in paper)
  #Voltage term in Poissons Eqaution
  [potential_diffusion_dom0]
    type = CoeffDiffusionLin
    variable = potential
    position_units = ${dom0Scale}
  []
  #Ion term in Poissons Equation
  [Ar+_charge_source]
    type = ChargeSourceMoles_KV
    variable = potential
    charged = Ar+
  []
  #Electron term in Poissons Equation
  [em_charge_source]
    type = ChargeSourceMoles_KV
    variable = potential
    charged = em
  []

  #Since the paper uses electron temperature as a variable, the energy equation is in
  #a different form but should be the same physics
  #Time Derivative term of electron energy
  [mean_en_time_deriv]
    type = ElectronTimeDerivative
    variable = mean_en
  []
  #Advection term of electron energy
  [mean_en_advection]
    type = EFieldAdvection
    variable = mean_en
    position_units = ${dom0Scale}
  []
  #Diffusion term of electrons energy
  [mean_en_diffusion]
    type = CoeffDiffusion
    variable = mean_en
    position_units = ${dom0Scale}
  []
  #Joule Heating term
  [mean_en_joule_heating]
    type = JouleHeating
    variable = mean_en
    em = em
    position_units = ${dom0Scale}
  []
  #Energy loss from ionization
  [Ionization_Loss]
    type = EEDFEnergyLog
    variable = mean_en
    electrons = em
    target = Ar
    reaction = &#x27;em + Ar -&gt; em + em + Ar+&#x27;
    threshold_energy = -15.7
  []
  #Energy loss from excitation
  [Excitation_Loss]
    type = EEDFEnergyLog
    variable = mean_en
    electrons = em
    target = Ar
    reaction = &#x27;em + Ar -&gt; em + Ar*&#x27;
    threshold_energy = -11.56
  []
  #Energy loss from step-wise ionization
  [Stepwise_Ionization_Loss]
    type = EEDFEnergyLog
    variable = mean_en
    electrons = em
    target = Ar*
    reaction = &#x27;em + Ar* -&gt; em + em + Ar+&#x27;
    threshold_energy = -4.14
  []
  #Energy gain from superelastic collisions
  [Collisions_Loss]
    type = EEDFEnergyLog
    variable = mean_en
    electrons = em
    target = Ar*
    reaction = &#x27;em + Ar* -&gt; em + Ar&#x27;
    threshold_energy = 11.56
  []
  # Energy loss from elastic collisions
  [Elastic_loss]
    type = EEDFElasticLog
    variable = mean_en
    electrons = em
    target = Ar
    reaction = &#x27;em + Ar -&gt; em + Ar&#x27;
  []

  #Effective potential for the Ions
  [Ion_potential_time_deriv]
    type = TimeDerivative
    variable = potential_ion
  []
  [Ion_potential_reaction]
    type = ScaledReaction
    variable = potential_ion
    collision_freq = 1283370.875
  []
  [Ion_potential_coupled_force]
    type = CoupledForce
    variable = potential_ion
    v = potential
    coef = 1283370.875
  []
[]

[AuxVariables]
  [emDeBug]
  []
  [Ar+_DeBug]
  []
  [Ar*_DeBug]
  []
  [mean_enDeBug]
  []
  [potential_DeBug]
  []

  [Te]
    order = CONSTANT
    family = MONOMIAL
  []

  [x]
    order = CONSTANT
    family = MONOMIAL
  []
  [x_node]
  []

  [y]
    order = CONSTANT
    family = MONOMIAL
  []
  [y_node]
  []

  [rho]
    order = CONSTANT
    family = MONOMIAL
  []

  [em_lin]
    order = CONSTANT
    family = MONOMIAL
  []

  [Ar+_lin]
    order = CONSTANT
    family = MONOMIAL
  []

  [Ar*_lin]
    order = CONSTANT
    family = MONOMIAL
  []

  [Ar]
  []

  [Efieldx]
    order = CONSTANT
    family = MONOMIAL
  []
  [Efieldy]
    order = CONSTANT
    family = MONOMIAL
  []

  [Current_em]
    order = CONSTANT
    family = MONOMIAL
    block = &#x27;plasma&#x27;
  []
  [Current_Ar]
    order = CONSTANT
    family = MONOMIAL
    block = &#x27;plasma&#x27;
  []
  [emRate]
    order = CONSTANT
    family = MONOMIAL
    block = &#x27;plasma&#x27;
  []
  [exRate]
    order = CONSTANT
    family = MONOMIAL
    block = &#x27;plasma&#x27;
  []
  [swRate]
    order = CONSTANT
    family = MONOMIAL
    block = &#x27;plasma&#x27;
  []
  [deexRate]
    order = CONSTANT
    family = MONOMIAL
    block = &#x27;plasma&#x27;
  []
  [quRate]
    order = CONSTANT
    family = MONOMIAL
    block = &#x27;plasma&#x27;
  []
  [poolRate]
    order = CONSTANT
    family = MONOMIAL
    block = &#x27;plasma&#x27;
  []
  [TwoBRate]
    order = CONSTANT
    family = MONOMIAL
    block = &#x27;plasma&#x27;
  []
  [ThreeBRate]
    order = CONSTANT
    family = MONOMIAL
    block = &#x27;plasma&#x27;
  []

[]

[AuxKernels]
  #[emDeBug]
  #  type = DebugResidualAux
  #  variable = emDeBug
  #  debug_variable = em
  #[]
  #[Ar+_DeBug]
  #  type = DebugResidualAux
  #  variable = Ar+_DeBug
  #  debug_variable = Ar+
  #[]
  #[mean_enDeBug]
  #  type = DebugResidualAux
  #  variable = mean_enDeBug
  #  debug_variable = mean_en
  #[]
  #[Ar*_DeBug]
  #  type = DebugResidualAux
  #  variable = Ar*_DeBug
  #  debug_variable = Ar*
  #[]
  #[Potential_DeBug]
  #  type = DebugResidualAux
  #  variable = potential_DeBug
  #  debug_variable = potential
  #[]

  [emRate]
    type = ProcRateForRateCoeff
    variable = emRate
    v = em
    w = Ar
    reaction = &#x27;em + Ar -&gt; em + em + Ar+&#x27;
  []
  [exRate]
    type = ProcRateForRateCoeff
    variable = exRate
    v = em
    w = Ar*
    reaction = &#x27;em + Ar -&gt; em + Ar*&#x27;
  []
  [swRate]
    type = ProcRateForRateCoeff
    variable = swRate
    v = em
    w = Ar*
    reaction = &#x27;em + Ar* -&gt; em + em + Ar+&#x27;
  []
  [deexRate]
    type = ProcRateForRateCoeff
    variable = deexRate
    v = em
    w = Ar*
    reaction = &#x27;em + Ar* -&gt; em + Ar&#x27;
  []
  [quRate]
    type = ProcRateForRateCoeff
    variable = quRate
    v = em
    w = Ar*
    reaction = &#x27;em + Ar* -&gt; em + Ar_r&#x27;
  []
  [poolRate]
    type = ProcRateForRateCoeff
    variable = poolRate
    v = Ar*
    w = Ar*
    reaction = &#x27;Ar* + Ar* -&gt; Ar+ + Ar + em&#x27;
  []
  [TwoBRate]
    type = ProcRateForRateCoeff
    variable = TwoBRate
    v = Ar*
    w = Ar
    reaction = &#x27;Ar* + Ar -&gt; Ar + Ar&#x27;
  []
  [ThreeBRate]
    type = ProcRateForRateCoeffThreeBody
    variable = ThreeBRate
    v = Ar*
    w = Ar
    x = Ar
    reaction = &#x27;Ar* + Ar + Ar -&gt; Ar_2 + Ar&#x27;
  []
  [Te]
    type = ElectronTemperature
    variable = Te
    electron_density = em
    mean_en = mean_en
  []
  [x_g]
    type = Position
    variable = x
    position_units = ${dom0Scale}
  []
  [x_ng]
    type = Position
    variable = x_node
    position_units = ${dom0Scale}
  []

  [y_g]
    type = Position
    variable = y
    position_units = ${dom0Scale}
  []
  [y_ng]
    type = Position
    variable = y_node
    position_units = ${dom0Scale}
  []

  [em_lin]
    type = DensityMoles
    variable = em_lin
    density_log = em
  []
  [Ar+_lin]
    type = DensityMoles
    variable = Ar+_lin
    density_log = Ar+
  []
  [Ar*_lin]
    type = DensityMoles
    variable = Ar*_lin
    density_log = Ar*
  []

  [Ar_val]
    type = ConstantAux
    variable = Ar
    # value = 3.22e2
    value = -5.231208
    execute_on = INITIAL
  []

  [Efieldx_calc]
    type = Efield
    component = 0
    variable = Efieldx
    position_units = ${dom0Scale}
  []
  [Efieldy_calc]
    type = Efield
    component = 1
    variable = Efieldy
    position_units = ${dom0Scale}
  []

  [Current_em]
    type = ADCurrent
    density_log = em
    variable = Current_em
    art_diff = false
    block = &#x27;plasma&#x27;
    position_units = ${dom0Scale}
  []
  [Current_Ar]
    type = ADCurrent
    density_log = Ar+
    variable = Current_Ar
    art_diff = false
    block = &#x27;plasma&#x27;
    position_units = ${dom0Scale}
  []

[]

[BCs]
  #Voltage Boundary Condition, same as in paper
  [potential_top_plate]
    type = FunctionDirichletBC
    variable = potential
    boundary = &#x27;Top_Electrode&#x27;
    function = potential_top_bc_func
  []
  [potential_bottom_plate]
    type = FunctionDirichletBC
    variable = potential
    boundary = &#x27;Bottom_Electrode&#x27;
    function = potential_bottom_bc_func
  []
  [potential_dirichlet_bottom_plate]
    type = DirichletBC
    variable = potential
    boundary = &#x27;Walls&#x27;
    value = 0
  []
  [potential_Dielectric]
    type = EconomouDielectricBC
    variable = potential
    boundary = &#x27;Top_Insulator Bottom_Insulator&#x27;
    electrons = em
    ions = Ar+
    ion_potentials = potential_ion
    electron_energy = mean_en
    dielectric_constant = 1.859382e-11
    thickness = 0.0127
    emission_coeffs = 0.01
    position_units = ${dom0Scale}
  []

  #New Boundary conditions for electons, same as in paper
  [em_physical_diffusion]
    type = SakiyamaElectronDiffusionBC
    variable = em
    electron_energy = mean_en
    boundary = &#x27;Top_Electrode Bottom_Electrode Top_Insulator Bottom_Insulator Walls&#x27;
    position_units = ${dom0Scale}
  []
  [em_Ar+_second_emissions]
    type = SakiyamaSecondaryElectronBC
    variable = em
    ions = Ar+
    emission_coeffs = 0.01
    boundary = &#x27;Top_Electrode Bottom_Electrode Top_Insulator Bottom_Insulator Walls&#x27;
    position_units = ${dom0Scale}
  []

  #New Boundary conditions for ions, should be the same as in paper
  [Ar+_physical_advection]
    type = SakiyamaIonAdvectionBC
    variable = Ar+
    boundary = &#x27;Top_Electrode Bottom_Electrode Top_Insulator Bottom_Insulator Walls&#x27;
    position_units = ${dom0Scale}
  []

  #New Boundary conditions for ions, should be the same as in paper
  #(except the metastables are not set to zero, since Zapdos uses log form)
  [Ar*_physical_diffusion]
    type = LogDensityDirichletBC
    variable = Ar*
    boundary = &#x27;Top_Electrode Bottom_Electrode Top_Insulator Bottom_Insulator Walls&#x27;
    value = 100
  []

  #New Boundary conditions for mean energy, should be the same as in paper
  [mean_en_physical_diffusion]
    type = SakiyamaEnergyDiffusionBC
    variable = mean_en
    electrons = em
    boundary = &#x27;Top_Electrode Bottom_Electrode Top_Insulator Bottom_Insulator Walls&#x27;
    position_units = ${dom0Scale}
  []
  [mean_en_Ar+_second_emissions]
    type = SakiyamaEnergySecondaryElectronBC
    variable = mean_en
    electrons = em
    ions = Ar+
    Tse_equal_Te = true
    emission_coeffs = 0.01
    boundary = &#x27;Top_Electrode Bottom_Electrode Top_Insulator Bottom_Insulator Walls&#x27;
    position_units = ${dom0Scale}
  []

[]

[ICs]
  [em_ic]
    type = FunctionIC
    variable = em
    function = density_ic_func
  []
  [Ar+_ic]
    type = FunctionIC
    variable = Ar+
    function = density_ic_func
  []
  [Ar*_ic]
    type = FunctionIC
    variable = Ar*
    function = meta_density_ic_func
  []
  [mean_en_ic]
    type = FunctionIC
    variable = mean_en
    function = energy_density_ic_func
  []

  [potential_ic]
    type = FunctionIC
    variable = potential
    function = potential_ic_func
  []
[]

[Functions]
  [potential_top_bc_func]
    type = ParsedFunction
    expression = &#x27;50*sin(2*3.1415926*13.56e6*t)&#x27;
  []
  [potential_bottom_bc_func]
    type = ParsedFunction
    expression = &#x27;-50*sin(2*3.1415926*13.56e6*t)&#x27;
  []
  [potential_ic_func]
    type = ParsedFunction
    expression = 0
  []
  [density_ic_func]
    type = ParsedFunction
    expression = &#x27;log((1e14)/6.022e23)&#x27;
  []
  [meta_density_ic_func]
    type = ParsedFunction
    expression = &#x27;log((1e16)/6.022e23)&#x27;
  []
  [energy_density_ic_func]
    type = ParsedFunction
    expression = &#x27;log((3./2.) * 4) + log((1e14)/6.022e23)&#x27;
  []
[]

[Materials]
  [field_solver]
    type = FieldSolverMaterial
    potential = potential
  []
  [GasBasics]
    type = GasElectronMoments
    interp_trans_coeffs = true
    interp_elastic_coeff = false
    ramp_trans_coeffs = false
    user_p_gas = 133.322
    em = em
    mean_en = mean_en
    user_se_coeff = 0.00
    property_tables_file = Argon_reactions_paper_RateCoefficients/electron_moments.txt
  []
  [gas_species_0]
    type = ADHeavySpecies
    heavy_species_name = Ar+
    heavy_species_mass = 6.64e-26
    heavy_species_charge = 1.0
    mobility = 1.44409938
    diffusivity = 6.428571e-2
  []
  [gas_species_1]
    type = ADHeavySpecies
    heavy_species_name = Ar*
    heavy_species_mass = 6.64e-26
    heavy_species_charge = 0.0
    diffusivity = 7.515528e-2
  []
  [gas_species_2]
    type = ADHeavySpecies
    heavy_species_name = Ar
    heavy_species_mass = 6.64e-26
    heavy_species_charge = 0.0
  []
  [reaction_00]
    type = ZapdosEEDFRateConstant
    mean_energy = mean_en
    property_file = &#x27;Argon_reactions_paper_RateCoefficients/ar_elastic.txt&#x27;
    reaction = &#x27;em + Ar -&gt; em + Ar&#x27;
    electrons = em
  []
  [reaction_0]
    type = ZapdosEEDFRateConstant
    property_file = &#x27;Argon_reactions_paper_RateCoefficients/ar_excitation.txt&#x27;
    reaction = &#x27;em + Ar -&gt; em + Ar*&#x27;
    mean_energy = mean_en
    electrons = em
  []
  [reaction_1]
    type = ZapdosEEDFRateConstant
    property_file = &#x27;Argon_reactions_paper_RateCoefficients/ar_ionization.txt&#x27;
    reaction = &#x27;em + Ar -&gt; em + em + Ar+&#x27;
    mean_energy = mean_en
    electrons = em
  []
  [reaction_2]
    type = ZapdosEEDFRateConstant
    property_file = &#x27;Argon_reactions_paper_RateCoefficients/ar_deexcitation.txt&#x27;
    reaction = &#x27;em + Ar* -&gt; em + Ar&#x27;
    mean_energy = mean_en
    electrons = em
  []
  [reaction_3]
    type = ZapdosEEDFRateConstant
    property_file = &#x27;Argon_reactions_paper_RateCoefficients/ar_excited_ionization.txt&#x27;
    reaction = &#x27;em + Ar* -&gt; em + em + Ar+&#x27;
    mean_energy = mean_en
    electrons = em
  []
  [reaction_4]
    type = GenericRateConstant
    reaction = &#x27;em + Ar* -&gt; em + Ar_r&#x27;
    #reaction_rate_value = 2e-13
    reaction_rate_value = 1.2044e11
  []
  [reaction_5]
    type = GenericRateConstant
    reaction = &#x27;Ar* + Ar* -&gt; Ar+ + Ar + em&#x27;
    #reaction_rate_value = 6.2e-16
    reaction_rate_value = 373364000
  []
  [reaction_6]
    type = GenericRateConstant
    reaction = &#x27;Ar* + Ar -&gt; Ar + Ar&#x27;
    #reaction_rate_value = 3e-21
    reaction_rate_value = 1806.6
  []
  [reaction_7]
    type = GenericRateConstant
    reaction = &#x27;Ar* + Ar + Ar -&gt; Ar_2 + Ar&#x27;
    #reaction_rate_value = 1.1e-42
    reaction_rate_value = 398909.324
  []
[]

#New postprocessor that calculates the inverse of the plasma frequency
[Postprocessors]
  [InversePlasmaFreq]
    type = PlasmaFrequencyInverse
    variable = em
    use_moles = true
    execute_on = &#x27;INITIAL TIMESTEP_BEGIN&#x27;
  []
[]

[Preconditioning]
  active = &#x27;smp&#x27;
  [smp]
    type = SMP
    full = true
  []

  [fdp]
    type = FDP
    full = true
  []
[]

[Executioner]
  type = Transient
  end_time = 7.4e-3
  dtmax = 1e-9
  petsc_options = &#x27;-snes_converged_reason -snes_linesearch_monitor&#x27;
  solve_type = NEWTON
  petsc_options_iname = &#x27;-pc_type -pc_factor_shift_type -pc_factor_shift_amount -ksp_type -snes_linesearch_minlambda&#x27;
  petsc_options_value = &#x27;lu NONZERO 1.e-10 fgmres 1e-3&#x27;
  nl_rel_tol = 1e-8
  #nl_abs_tol = 7.6e-5
  dtmin = 1e-14
  l_max_its = 20

  #Time steps based on the inverse of the plasma frequency
  #[TimeSteppers]
  # [Postprocessor]
  #    type = PostprocessorDT
  #    postprocessor = InversePlasmaFreq
  #    scale = 0.1
  #  []
  #[]
[]

[Outputs]
  perf_graph = true
  [out]
    type = Exodus
  []
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="9592669c-a524-4639-ae7a-289a65c91eb2"><div class="modal-content"><h4>(test/tests/DriftDiffusionAction/2D_RF_Plasma_no_actions.i)</h4><pre style="max-height:350px;"><code class="language-moose">#This is the input file that supplied the gold output file.
#It is the same as the input file in
#tests/Lymberopoulos_rf_discharge/Lymberopoulos_with_argon_metastables_2D_At100mTorr_CoarseMesh.i,
#execpt some of the Aux Variables are renamed for the Action test

dom0Scale = 25.4e-3

[GlobalParams]
  potential_units = V
  use_moles = true
[]

[Mesh]
  type = FileMesh
  file = &#x27;GEC_mesh_coarse.msh&#x27;
  coord_type = RZ
  rz_coord_axis = Y
[]

[Variables]
  [em]
  []

  [Ar+]
  []

  [Ar*]
  []

  [mean_en]
  []

  [potential]
  []

  [potential_ion]
  []
[]

[Kernels]
  #Electron Equations (Same as in paper)
  #Time Derivative term of electron
  [em_time_deriv]
    type = ElectronTimeDerivative
    variable = em
  []
  #Advection term of electron
  [em_advection]
    type = EFieldAdvection
    variable = em
    position_units = ${dom0Scale}
  []
  #Diffusion term of electrons
  [em_diffusion]
    type = CoeffDiffusion
    variable = em
    position_units = ${dom0Scale}
  []
  #Net electron production from ionization
  [em_ionization]
    type = EEDFReactionLog
    variable = em
    electrons = em
    target = Ar
    mean_energy = mean_en
    reaction = &#x27;em + Ar -&gt; em + em + Ar+&#x27;
    coefficient = 1
  []
  #Net electron production from step-wise ionization
  [em_stepwise_ionization]
    type = EEDFReactionLog
    variable = em
    electrons = em
    target = Ar*
    mean_energy = mean_en
    reaction = &#x27;em + Ar* -&gt; em + em + Ar+&#x27;
    coefficient = 1
  []
  #Net electron production from metastable pooling
  [em_pooling]
    type = ReactionSecondOrderLog
    variable = em
    v = Ar*
    w = Ar*
    reaction = &#x27;Ar* + Ar* -&gt; Ar+ + Ar + em&#x27;
    coefficient = 1
  []

  #Argon Ion Equations (Same as in paper)
  #Time Derivative term of the ions
  [Ar+_time_deriv]
    type = ElectronTimeDerivative
    variable = Ar+
  []
  #Advection term of ions
  [Ar+_advection]
    type = EFieldAdvection
    variable = Ar+
    field_property_name = field_solver_interface_property_eff
    position_units = ${dom0Scale}
  []
  [Ar+_diffusion]
    type = CoeffDiffusion
    variable = Ar+
    position_units = ${dom0Scale}
  []
  #Net ion production from ionization
  [Ar+_ionization]
    type = EEDFReactionLog
    variable = Ar+
    electrons = em
    target = Ar
    mean_energy = mean_en
    reaction = &#x27;em + Ar -&gt; em + em + Ar+&#x27;
    coefficient = 1
  []
  #Net ion production from step-wise ionization
  [Ar+_stepwise_ionization]
    type = EEDFReactionLog
    variable = Ar+
    electrons = em
    target = Ar*
    mean_energy = mean_en
    reaction = &#x27;em + Ar* -&gt; em + em + Ar+&#x27;
    coefficient = 1
  []
  #Net ion production from metastable pooling
  [Ar+_pooling]
    type = ReactionSecondOrderLog
    variable = Ar+
    v = Ar*
    w = Ar*
    reaction = &#x27;Ar* + Ar* -&gt; Ar+ + Ar + em&#x27;
    coefficient = 1
  []

  #Argon Excited Equations (Same as in paper)
  #Time Derivative term of excited Argon
  [Ar*_time_deriv]
    type = ElectronTimeDerivative
    variable = Ar*
  []
  #Diffusion term of excited Argon
  [Ar*_diffusion]
    type = CoeffDiffusion
    variable = Ar*
    position_units = ${dom0Scale}
  []
  #Net excited Argon production from excitation
  [Ar*_excitation]
    type = EEDFReactionLog
    variable = Ar*
    electrons = em
    target = Ar
    mean_energy = mean_en
    reaction = &#x27;em + Ar -&gt; em + Ar*&#x27;
    coefficient = 1
  []
  #Net excited Argon loss from step-wise ionization
  [Ar*_stepwise_ionization]
    type = EEDFReactionLog
    variable = Ar*
    electrons = em
    target = Ar*
    mean_energy = mean_en
    reaction = &#x27;em + Ar* -&gt; em + em + Ar+&#x27;
    coefficient = -1
  []
  #Net excited Argon loss from superelastic collisions
  [Ar*_collisions]
    type = EEDFReactionLog
    variable = Ar*
    electrons = em
    target = Ar*
    mean_energy = mean_en
    reaction = &#x27;em + Ar* -&gt; em + Ar&#x27;
    coefficient = -1
  []
  #Net excited Argon loss from quenching to resonant
  [Ar*_quenching]
    type = EEDFReactionLog
    variable = Ar*
    electrons = em
    target = Ar*
    mean_energy = mean_en
    reaction = &#x27;em + Ar* -&gt; em + Ar_r&#x27;
    coefficient = -1
  []
  #Net excited Argon loss from  metastable pooling
  [Ar*_pooling]
    type = ReactionSecondOrderLog
    variable = Ar*
    v = Ar*
    w = Ar*
    reaction = &#x27;Ar* + Ar* -&gt; Ar+ + Ar + em&#x27;
    coefficient = -2
    _v_eq_u = true
    _w_eq_u = true
  []
  #Net excited Argon loss from two-body quenching
  [Ar*_2B_quenching]
    type = ReactionSecondOrderLog
    variable = Ar*
    v = Ar*
    w = Ar
    reaction = &#x27;Ar* + Ar -&gt; Ar + Ar&#x27;
    coefficient = -1
    _v_eq_u = true
  []
  #Net excited Argon loss from three-body quenching
  [Ar*_3B_quenching]
    type = ReactionThirdOrderLog
    variable = Ar*
    v = Ar*
    w = Ar
    x = Ar
    reaction = &#x27;Ar* + Ar + Ar -&gt; Ar_2 + Ar&#x27;
    coefficient = -1
    _v_eq_u = true
  []

  #Voltage Equations (Same as in paper)
  #Voltage term in Poissons Eqaution
  [potential_diffusion_dom0]
    type = CoeffDiffusionLin
    variable = potential
    position_units = ${dom0Scale}
  []
  #Ion term in Poissons Equation
  [Ar+_charge_source]
    type = ChargeSourceMoles_KV
    variable = potential
    charged = Ar+
  []
  #Electron term in Poissons Equation
  [em_charge_source]
    type = ChargeSourceMoles_KV
    variable = potential
    charged = em
  []

  #Since the paper uses electron temperature as a variable, the energy equation is in
  #a different form but should be the same physics
  #Time Derivative term of electron energy
  [mean_en_time_deriv]
    type = ElectronTimeDerivative
    variable = mean_en
  []
  #Advection term of electron energy
  [mean_en_advection]
    type = EFieldAdvection
    variable = mean_en
    position_units = ${dom0Scale}
  []
  #Diffusion term of electrons energy
  [mean_en_diffusion]
    type = CoeffDiffusion
    variable = mean_en
    position_units = ${dom0Scale}
  []
  #Joule Heating term
  [mean_en_joule_heating]
    type = JouleHeating
    variable = mean_en
    em = em
    position_units = ${dom0Scale}
  []
  #Energy loss from ionization
  [Ionization_Loss]
    type = EEDFEnergyLog
    variable = mean_en
    electrons = em
    target = Ar
    reaction = &#x27;em + Ar -&gt; em + em + Ar+&#x27;
    threshold_energy = -15.7
  []
  #Energy loss from excitation
  [Excitation_Loss]
    type = EEDFEnergyLog
    variable = mean_en
    electrons = em
    target = Ar
    reaction = &#x27;em + Ar -&gt; em + Ar*&#x27;
    threshold_energy = -11.56
  []
  #Energy loss from step-wise ionization
  [Stepwise_Ionization_Loss]
    type = EEDFEnergyLog
    variable = mean_en
    electrons = em
    target = Ar*
    reaction = &#x27;em + Ar* -&gt; em + em + Ar+&#x27;
    threshold_energy = -4.14
  []
  #Energy gain from superelastic collisions
  [Collisions_Loss]
    type = EEDFEnergyLog
    variable = mean_en
    electrons = em
    target = Ar*
    reaction = &#x27;em + Ar* -&gt; em + Ar&#x27;
    threshold_energy = 11.56
  []
  # Energy loss from elastic collisions
  [Elastic_loss]
    type = EEDFElasticLog
    variable = mean_en
    electrons = em
    target = Ar
    reaction = &#x27;em + Ar -&gt; em + Ar&#x27;
  []

  #Effective potential for the Ions
  [Ion_potential_time_deriv]
    type = TimeDerivative
    variable = potential_ion
  []
  [Ion_potential_reaction]
    type = ScaledReaction
    variable = potential_ion
    collision_freq = 1283370.875
  []
  [Ion_potential_coupled_force]
    type = CoupledForce
    variable = potential_ion
    v = potential
    coef = 1283370.875
  []
[]

[AuxVariables]
  [e_temp]
    order = CONSTANT
    family = MONOMIAL
  []

  [x_position]
    order = CONSTANT
    family = MONOMIAL
  []
  [x_node]
  []

  [y_position]
    order = CONSTANT
    family = MONOMIAL
  []
  [y_node]
  []

  [rho]
    order = CONSTANT
    family = MONOMIAL
  []

  [em_density]
    order = CONSTANT
    family = MONOMIAL
  []

  [Ar+_density]
    order = CONSTANT
    family = MONOMIAL
  []

  [Ar*_density]
    order = CONSTANT
    family = MONOMIAL
  []

  [Ar]
  []

  [Efieldx]
    order = CONSTANT
    family = MONOMIAL
  []
  [Efieldy]
    order = CONSTANT
    family = MONOMIAL
  []

  [Current_em]
    order = CONSTANT
    family = MONOMIAL
    block = &#x27;plasma&#x27;
  []
  [Current_Ar+]
    order = CONSTANT
    family = MONOMIAL
    block = &#x27;plasma&#x27;
  []
  [emRate]
    order = CONSTANT
    family = MONOMIAL
    block = &#x27;plasma&#x27;
  []
  [exRate]
    order = CONSTANT
    family = MONOMIAL
    block = &#x27;plasma&#x27;
  []
  [swRate]
    order = CONSTANT
    family = MONOMIAL
    block = &#x27;plasma&#x27;
  []
  [deexRate]
    order = CONSTANT
    family = MONOMIAL
    block = &#x27;plasma&#x27;
  []
  [quRate]
    order = CONSTANT
    family = MONOMIAL
    block = &#x27;plasma&#x27;
  []
  [poolRate]
    order = CONSTANT
    family = MONOMIAL
    block = &#x27;plasma&#x27;
  []
  [TwoBRate]
    order = CONSTANT
    family = MONOMIAL
    block = &#x27;plasma&#x27;
  []
  [ThreeBRate]
    order = CONSTANT
    family = MONOMIAL
    block = &#x27;plasma&#x27;
  []

[]

[AuxKernels]
  [emRate]
    type = ProcRateForRateCoeff
    variable = emRate
    v = em
    w = Ar
    reaction = &#x27;em + Ar -&gt; em + em + Ar+&#x27;
  []
  [exRate]
    type = ProcRateForRateCoeff
    variable = exRate
    v = em
    w = Ar*
    reaction = &#x27;em + Ar -&gt; em + Ar*&#x27;
  []
  [swRate]
    type = ProcRateForRateCoeff
    variable = swRate
    v = em
    w = Ar*
    reaction = &#x27;em + Ar* -&gt; em + em + Ar+&#x27;
  []
  [deexRate]
    type = ProcRateForRateCoeff
    variable = deexRate
    v = em
    w = Ar*
    reaction = &#x27;em + Ar* -&gt; em + Ar&#x27;
  []
  [quRate]
    type = ProcRateForRateCoeff
    variable = quRate
    v = em
    w = Ar*
    reaction = &#x27;em + Ar* -&gt; em + Ar_r&#x27;
  []
  [poolRate]
    type = ProcRateForRateCoeff
    variable = poolRate
    v = Ar*
    w = Ar*
    reaction = &#x27;Ar* + Ar* -&gt; Ar+ + Ar + em&#x27;
  []
  [TwoBRate]
    type = ProcRateForRateCoeff
    variable = TwoBRate
    v = Ar*
    w = Ar
    reaction = &#x27;Ar* + Ar -&gt; Ar + Ar&#x27;
  []
  [ThreeBRate]
    type = ProcRateForRateCoeffThreeBody
    variable = ThreeBRate
    v = Ar*
    w = Ar
    x = Ar
    reaction = &#x27;Ar* + Ar + Ar -&gt; Ar_2 + Ar&#x27;
  []
  [e_temp]
    type = ElectronTemperature
    variable = e_temp
    electron_density = em
    mean_en = mean_en
  []
  [x_g]
    type = Position
    variable = x_position
    component = 0
    position_units = ${dom0Scale}
  []
  [x_ng]
    type = Position
    variable = x_node
    component = 0
    position_units = ${dom0Scale}
  []

  [y_g]
    type = Position
    variable = y_position
    component = 1
    position_units = ${dom0Scale}
  []
  [y_ng]
    type = Position
    variable = y_node
    component = 1
    position_units = ${dom0Scale}
  []

  [em_density]
    type = DensityMoles
    variable = em_density
    density_log = em
  []
  [Ar+_density]
    type = DensityMoles
    variable = Ar+_density
    density_log = Ar+
  []
  [Ar*_density]
    type = DensityMoles
    variable = Ar*_density
    density_log = Ar*
  []

  [Ar_val]
    type = ConstantAux
    variable = Ar
    # value = 3.22e2
    value = -5.231208
    execute_on = INITIAL
  []

  [Efieldx_calc]
    type = Efield
    component = 0
    variable = Efieldx
    position_units = ${dom0Scale}
  []
  [Efieldy_calc]
    type = Efield
    component = 1
    variable = Efieldy
    position_units = ${dom0Scale}
  []

  [Current_em]
    type = ADCurrent
    density_log = em
    variable = Current_em
    art_diff = false
    block = &#x27;plasma&#x27;
    position_units = ${dom0Scale}
  []
  [Current_Ar]
    type = ADCurrent
    field_property_name = field_solver_interface_property_eff
    density_log = Ar+
    variable = Current_Ar+
    art_diff = false
    block = &#x27;plasma&#x27;
    position_units = ${dom0Scale}
  []

[]

[BCs]
  #Voltage Boundary Condition, same as in paper
  [potential_top_plate]
    type = FunctionDirichletBC
    variable = potential
    boundary = &#x27;Top_Electrode&#x27;
    function = potential_top_bc_func
    preset = false
  []
  [potential_bottom_plate]
    type = FunctionDirichletBC
    variable = potential
    boundary = &#x27;Bottom_Electrode&#x27;
    function = potential_bottom_bc_func
    preset = false
  []
  [potential_dirichlet_bottom_plate]
    type = DirichletBC
    variable = potential
    boundary = &#x27;Walls&#x27;
    value = 0
    preset = false
  []
  [potential_Dielectric]
    type = EconomouDielectricBC
    variable = potential
    boundary = &#x27;Top_Insulator Bottom_Insulator&#x27;
    electrons = em
    ions = Ar+
    ion_potentials = potential_ion
    electron_energy = mean_en
    dielectric_constant = 1.859382e-11
    thickness = 0.0127
    emission_coeffs = 0.01
    position_units = ${dom0Scale}
  []

  #New Boundary conditions for electons, same as in paper
  [em_physical_diffusion]
    type = SakiyamaElectronDiffusionBC
    variable = em
    electron_energy = mean_en
    boundary = &#x27;Top_Electrode Bottom_Electrode Top_Insulator Bottom_Insulator Walls&#x27;
    position_units = ${dom0Scale}
  []
  [em_Ar+_second_emissions]
    type = SakiyamaSecondaryElectronBC
    variable = em
    field_property_name = field_solver_interface_property_eff
    ions = Ar+
    emission_coeffs = 0.01
    boundary = &#x27;Top_Electrode Bottom_Electrode Top_Insulator Bottom_Insulator Walls&#x27;
    position_units = ${dom0Scale}
  []

  #New Boundary conditions for ions, should be the same as in paper
  [Ar+_physical_advection]
    type = SakiyamaIonAdvectionBC
    variable = Ar+
    field_property_name = field_solver_interface_property_eff
    boundary = &#x27;Top_Electrode Bottom_Electrode Top_Insulator Bottom_Insulator Walls&#x27;
    position_units = ${dom0Scale}
  []

  #New Boundary conditions for ions, should be the same as in paper
  #(except the metastables are not set to zero, since Zapdos uses log form)
  [Ar*_physical_diffusion]
    type = LogDensityDirichletBC
    variable = Ar*
    boundary = &#x27;Top_Electrode Bottom_Electrode Top_Insulator Bottom_Insulator Walls&#x27;
    value = 100
  []

  #New Boundary conditions for mean energy, should be the same as in paper
  [mean_en_physical_diffusion]
    type = SakiyamaEnergyDiffusionBC
    variable = mean_en
    electrons = em
    boundary = &#x27;Top_Electrode Bottom_Electrode Top_Insulator Bottom_Insulator Walls&#x27;
    position_units = ${dom0Scale}
  []
  [mean_en_Ar+_second_emissions]
    type = SakiyamaEnergySecondaryElectronBC
    variable = mean_en
    electrons = em
    ions = Ar+
    field_property_name = field_solver_interface_property_eff
    Tse_equal_Te = true
    emission_coeffs = 0.01
    boundary = &#x27;Top_Electrode Bottom_Electrode Top_Insulator Bottom_Insulator Walls&#x27;
    position_units = ${dom0Scale}
  []

[]

[ICs]
  [em_ic]
    type = FunctionIC
    variable = em
    function = density_ic_func
  []
  [Ar+_ic]
    type = FunctionIC
    variable = Ar+
    function = density_ic_func
  []
  [Ar*_ic]
    type = FunctionIC
    variable = Ar*
    function = meta_density_ic_func
  []
  [mean_en_ic]
    type = FunctionIC
    variable = mean_en
    function = energy_density_ic_func
  []

  [potential_ic]
    type = FunctionIC
    variable = potential
    function = potential_ic_func
  []
[]

[Functions]
  [potential_top_bc_func]
    type = ParsedFunction
    expression = &#x27;50*sin(2*3.1415926*13.56e6*t)&#x27;
  []
  [potential_bottom_bc_func]
    type = ParsedFunction
    expression = &#x27;-50*sin(2*3.1415926*13.56e6*t)&#x27;
  []
  [potential_ic_func]
    type = ParsedFunction
    expression = 0
  []
  [density_ic_func]
    type = ParsedFunction
    expression = &#x27;log((1e14)/6.022e23)&#x27;
  []
  [meta_density_ic_func]
    type = ParsedFunction
    expression = &#x27;log((1e16)/6.022e23)&#x27;
  []
  [energy_density_ic_func]
    type = ParsedFunction
    expression = &#x27;log((3./2.) * 4) + log((1e14)/6.022e23)&#x27;
  []
[]

[Materials]
  [field_solver]
    type = FieldSolverMaterial
    potential = potential
  []
  [field_solver_eff]
    type = FieldSolverMaterial
    potential = potential_ion
    property_name = field_solver_interface_property_eff
  []
  [GasBasics]
    type = GasElectronMoments
    interp_trans_coeffs = true
    interp_elastic_coeff = false
    ramp_trans_coeffs = false
    user_p_gas = 133.322
    em = em
    mean_en = mean_en
    user_se_coeff = 0.00
    property_tables_file = Argon_reactions_paper_RateCoefficients/electron_moments.txt
  []
  [gas_species_0]
    type = ADHeavySpecies
    heavy_species_name = Ar+
    heavy_species_mass = 6.64e-26
    heavy_species_charge = 1.0
    mobility = 1.44409938
    diffusivity = 6.428571e-2
  []
  [gas_species_1]
    type = ADHeavySpecies
    heavy_species_name = Ar*
    heavy_species_mass = 6.64e-26
    heavy_species_charge = 0.0
    diffusivity = 7.515528e-2
  []
  [gas_species_2]
    type = ADHeavySpecies
    heavy_species_name = Ar
    heavy_species_mass = 6.64e-26
    heavy_species_charge = 0.0
  []
  [reaction_00]
    type = ZapdosEEDFRateConstant
    mean_energy = mean_en
    property_file = &#x27;Argon_reactions_paper_RateCoefficients/ar_elastic.txt&#x27;
    reaction = &#x27;em + Ar -&gt; em + Ar&#x27;
    electrons = em
  []
  [reaction_0]
    type = ZapdosEEDFRateConstant
    property_file = &#x27;Argon_reactions_paper_RateCoefficients/ar_excitation.txt&#x27;
    reaction = &#x27;em + Ar -&gt; em + Ar*&#x27;
    mean_energy = mean_en
    electrons = em
  []
  [reaction_1]
    type = ZapdosEEDFRateConstant
    property_file = &#x27;Argon_reactions_paper_RateCoefficients/ar_ionization.txt&#x27;
    reaction = &#x27;em + Ar -&gt; em + em + Ar+&#x27;
    mean_energy = mean_en
    electrons = em
  []
  [reaction_2]
    type = ZapdosEEDFRateConstant
    reaction = &#x27;em + Ar* -&gt; em + Ar&#x27;
    property_file = &#x27;Argon_reactions_paper_RateCoefficients/ar_deexcitation.txt&#x27;
    mean_energy = mean_en
    electrons = em
  []
  [reaction_3]
    type = ZapdosEEDFRateConstant
    reaction = &#x27;em + Ar* -&gt; em + em + Ar+&#x27;
    property_file = &#x27;Argon_reactions_paper_RateCoefficients/ar_excited_ionization.txt&#x27;
    mean_energy = mean_en
    electrons = em
  []
  [reaction_4]
    type = GenericRateConstant
    reaction = &#x27;em + Ar* -&gt; em + Ar_r&#x27;
    #reaction_rate_value = 2e-13
    reaction_rate_value = 1.2044e11
  []
  [reaction_5]
    type = GenericRateConstant
    reaction = &#x27;Ar* + Ar* -&gt; Ar+ + Ar + em&#x27;
    #reaction_rate_value = 6.2e-16
    reaction_rate_value = 373364000
  []
  [reaction_6]
    type = GenericRateConstant
    reaction = &#x27;Ar* + Ar -&gt; Ar + Ar&#x27;
    #reaction_rate_value = 3e-21
    reaction_rate_value = 1806.6
  []
  [reaction_7]
    type = GenericRateConstant
    reaction = &#x27;Ar* + Ar + Ar -&gt; Ar_2 + Ar&#x27;
    #reaction_rate_value = 1.1e-42
    reaction_rate_value = 398909.324
  []
[]

#New postprocessor that calculates the inverse of the plasma frequency
[Postprocessors]
  [InversePlasmaFreq]
    type = PlasmaFrequencyInverse
    variable = em
    use_moles = true
    execute_on = &#x27;INITIAL TIMESTEP_BEGIN&#x27;
  []
[]

[Preconditioning]
  active = &#x27;smp&#x27;
  [smp]
    type = SMP
    full = true
  []

  [fdp]
    type = FDP
    full = true
  []
[]

[Executioner]
  type = Transient
  #end_time = 7.4e-3
  end_time = 1e-7
  dtmax = 1e-9
  petsc_options = &#x27;-snes_converged_reason -snes_linesearch_monitor&#x27;
  solve_type = NEWTON
  petsc_options_iname = &#x27;-pc_type -pc_factor_shift_type -pc_factor_shift_amount -ksp_type -snes_linesearch_minlambda&#x27;
  petsc_options_value = &#x27;lu NONZERO 1.e-10 fgmres 1e-3&#x27;
  nl_rel_tol = 1e-12
  #nl_abs_tol = 7.6e-5
  dtmin = 1e-14
  l_max_its = 20

  #Time steps based on the inverse of the plasma frequency
  #[TimeSteppers]
  #  [Postprocessor]
  #    type = PostprocessorDT
  #    postprocessor = InversePlasmaFreq
  #    scale = 0.1
  #  []
  #[]
[]

[Outputs]
  file_base = &#x27;2D_RF_out&#x27;
  perf_graph = true
  [out]
    type = Exodus
  []
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="14da64d1-59a1-496d-a8ea-b3803d86e73e"><div class="modal-content"><h4>(test/tests/Lymberopoulos_rf_discharge/Lymberopoulos_with_argon_metastables_2D_At100mTorr_CoarseMesh.i)</h4><pre style="max-height:350px;"><code class="language-moose">dom0Scale = 25.4e-3

[GlobalParams]
  potential_units = V
  use_moles = true
[]

[Mesh]
  type = FileMesh
  file = &#x27;GEC_mesh_coarse.msh&#x27;
  coord_type = RZ
  rz_coord_axis = Y
[]

[Variables]
  [em]
  []

  [Ar+]
  []

  [Ar*]
  []

  [mean_en]
  []

  [potential]
  []

  [potential_ion]
  []
[]

[Kernels]
  #Electron Equations (Same as in paper)
  #Time Derivative term of electron
  [em_time_deriv]
    type = ElectronTimeDerivative
    variable = em
  []
  #Advection term of electron
  [em_advection]
    type = EFieldAdvection
    variable = em
    position_units = ${dom0Scale}
  []
  #Diffusion term of electrons
  [em_diffusion]
    type = CoeffDiffusion
    variable = em
    position_units = ${dom0Scale}
  []
  #Net electron production from ionization
  [em_ionization]
    type = EEDFReactionLog
    variable = em
    electrons = em
    target = Ar
    mean_energy = mean_en
    reaction = &#x27;em + Ar -&gt; em + em + Ar+&#x27;
    coefficient = 1
  []
  #Net electron production from step-wise ionization
  [em_stepwise_ionization]
    type = EEDFReactionLog
    variable = em
    electrons = em
    target = Ar*
    mean_energy = mean_en
    reaction = &#x27;em + Ar* -&gt; em + em + Ar+&#x27;
    coefficient = 1
  []
  #Net electron production from metastable pooling
  [em_pooling]
    type = ReactionSecondOrderLog
    variable = em
    v = Ar*
    w = Ar*
    reaction = &#x27;Ar* + Ar* -&gt; Ar+ + Ar + em&#x27;
    coefficient = 1
  []

  #Argon Ion Equations (Same as in paper)
  #Time Derivative term of the ions
  [Ar+_time_deriv]
    type = ElectronTimeDerivative
    variable = Ar+
  []
  #Advection term of ions
  [Ar+_advection]
    type = EFieldAdvection
    variable = Ar+
    field_property_name = field_ion
    position_units = ${dom0Scale}
  []
  [Ar+_diffusion]
    type = CoeffDiffusion
    variable = Ar+
    position_units = ${dom0Scale}
  []
  #Net ion production from ionization
  [Ar+_ionization]
    type = EEDFReactionLog
    variable = Ar+
    electrons = em
    target = Ar
    mean_energy = mean_en
    reaction = &#x27;em + Ar -&gt; em + em + Ar+&#x27;
    coefficient = 1
  []
  #Net ion production from step-wise ionization
  [Ar+_stepwise_ionization]
    type = EEDFReactionLog
    variable = Ar+
    electrons = em
    target = Ar*
    mean_energy = mean_en
    reaction = &#x27;em + Ar* -&gt; em + em + Ar+&#x27;
    coefficient = 1
  []
  #Net ion production from metastable pooling
  [Ar+_pooling]
    type = ReactionSecondOrderLog
    variable = Ar+
    v = Ar*
    w = Ar*
    reaction = &#x27;Ar* + Ar* -&gt; Ar+ + Ar + em&#x27;
    coefficient = 1
  []

  #Argon Excited Equations (Same as in paper)
  #Time Derivative term of excited Argon
  [Ar*_time_deriv]
    type = ElectronTimeDerivative
    variable = Ar*
  []
  #Diffusion term of excited Argon
  [Ar*_diffusion]
    type = CoeffDiffusion
    variable = Ar*
    position_units = ${dom0Scale}
  []
  #Net excited Argon production from excitation
  [Ar*_excitation]
    type = EEDFReactionLog
    variable = Ar*
    electrons = em
    target = Ar
    mean_energy = mean_en
    reaction = &#x27;em + Ar -&gt; em + Ar*&#x27;
    coefficient = 1
  []
  #Net excited Argon loss from step-wise ionization
  [Ar*_stepwise_ionization]
    type = EEDFReactionLog
    variable = Ar*
    electrons = em
    target = Ar*
    mean_energy = mean_en
    reaction = &#x27;em + Ar* -&gt; em + em + Ar+&#x27;
    coefficient = -1
  []
  #Net excited Argon loss from superelastic collisions
  [Ar*_collisions]
    type = EEDFReactionLog
    variable = Ar*
    electrons = em
    target = Ar*
    mean_energy = mean_en
    reaction = &#x27;em + Ar* -&gt; em + Ar&#x27;
    coefficient = -1
  []
  #Net excited Argon loss from quenching to resonant
  [Ar*_quenching]
    type = EEDFReactionLog
    variable = Ar*
    electrons = em
    target = Ar*
    mean_energy = mean_en
    reaction = &#x27;em + Ar* -&gt; em + Ar_r&#x27;
    coefficient = -1
  []
  #Net excited Argon loss from  metastable pooling
  [Ar*_pooling]
    type = ReactionSecondOrderLog
    variable = Ar*
    v = Ar*
    w = Ar*
    reaction = &#x27;Ar* + Ar* -&gt; Ar+ + Ar + em&#x27;
    coefficient = -2
    _v_eq_u = true
    _w_eq_u = true
  []
  #Net excited Argon loss from two-body quenching
  [Ar*_2B_quenching]
    type = ReactionSecondOrderLog
    variable = Ar*
    v = Ar*
    w = Ar
    reaction = &#x27;Ar* + Ar -&gt; Ar + Ar&#x27;
    coefficient = -1
    _v_eq_u = true
  []
  #Net excited Argon loss from three-body quenching
  [Ar*_3B_quenching]
    type = ReactionThirdOrderLog
    variable = Ar*
    v = Ar*
    w = Ar
    x = Ar
    reaction = &#x27;Ar* + Ar + Ar -&gt; Ar_2 + Ar&#x27;
    coefficient = -1
    _v_eq_u = true
  []

  #Voltage Equations (Same as in paper)
  #Voltage term in Poissons Eqaution
  [potential_diffusion_dom0]
    type = CoeffDiffusionLin
    variable = potential
    position_units = ${dom0Scale}
  []
  #Ion term in Poissons Equation
  [Ar+_charge_source]
    type = ChargeSourceMoles_KV
    variable = potential
    charged = Ar+
  []
  #Electron term in Poissons Equation
  [em_charge_source]
    type = ChargeSourceMoles_KV
    variable = potential
    charged = em
  []

  #Since the paper uses electron temperature as a variable, the energy equation is in
  #a different form but should be the same physics
  #Time Derivative term of electron energy
  [mean_en_time_deriv]
    type = ElectronTimeDerivative
    variable = mean_en
  []
  #Advection term of electron energy
  [mean_en_advection]
    type = EFieldAdvection
    variable = mean_en
    position_units = ${dom0Scale}
  []
  #Diffusion term of electrons energy
  [mean_en_diffusion]
    type = CoeffDiffusion
    variable = mean_en
    position_units = ${dom0Scale}
  []
  #Joule Heating term
  [mean_en_joule_heating]
    type = JouleHeating
    variable = mean_en
    em = em
    position_units = ${dom0Scale}
  []
  #Energy loss from ionization
  [Ionization_Loss]
    type = EEDFEnergyLog
    variable = mean_en
    electrons = em
    target = Ar
    reaction = &#x27;em + Ar -&gt; em + em + Ar+&#x27;
    threshold_energy = -15.7
  []
  #Energy loss from excitation
  [Excitation_Loss]
    type = EEDFEnergyLog
    variable = mean_en
    electrons = em
    target = Ar
    reaction = &#x27;em + Ar -&gt; em + Ar*&#x27;
    threshold_energy = -11.56
  []
  #Energy loss from step-wise ionization
  [Stepwise_Ionization_Loss]
    type = EEDFEnergyLog
    variable = mean_en
    electrons = em
    target = Ar*
    reaction = &#x27;em + Ar* -&gt; em + em + Ar+&#x27;
    threshold_energy = -4.14
  []
  #Energy gain from superelastic collisions
  [Collisions_Loss]
    type = EEDFEnergyLog
    variable = mean_en
    electrons = em
    target = Ar*
    reaction = &#x27;em + Ar* -&gt; em + Ar&#x27;
    threshold_energy = 11.56
  []
  # Energy loss from elastic collisions
  [Elastic_loss]
    type = EEDFElasticLog
    variable = mean_en
    electrons = em
    target = Ar
    reaction = &#x27;em + Ar -&gt; em + Ar&#x27;
  []

  #Effective potential for the Ions
  [Ion_potential_time_deriv]
    type = TimeDerivative
    variable = potential_ion
  []
  [Ion_potential_reaction]
    type = ScaledReaction
    variable = potential_ion
    collision_freq = 1283370.875
  []
  [Ion_potential_coupled_force]
    type = CoupledForce
    variable = potential_ion
    v = potential
    coef = 1283370.875
  []
[]

[AuxVariables]
  [emDeBug]
  []
  [Ar+_DeBug]
  []
  [Ar*_DeBug]
  []
  [mean_enDeBug]
  []
  [potential_DeBug]
  []

  [Te]
    order = CONSTANT
    family = MONOMIAL
  []

  [x]
    order = CONSTANT
    family = MONOMIAL
  []
  [x_node]
  []

  [y]
    order = CONSTANT
    family = MONOMIAL
  []
  [y_node]
  []

  [rho]
    order = CONSTANT
    family = MONOMIAL
  []

  [em_lin]
    order = CONSTANT
    family = MONOMIAL
  []

  [Ar+_lin]
    order = CONSTANT
    family = MONOMIAL
  []

  [Ar*_lin]
    order = CONSTANT
    family = MONOMIAL
  []

  [Ar]
  []

  [Efieldx]
    order = CONSTANT
    family = MONOMIAL
  []
  [Efieldy]
    order = CONSTANT
    family = MONOMIAL
  []

  [Current_em]
    order = CONSTANT
    family = MONOMIAL
    block = &#x27;plasma&#x27;
  []
  [Current_Ar]
    order = CONSTANT
    family = MONOMIAL
    block = &#x27;plasma&#x27;
  []
  [emRate]
    order = CONSTANT
    family = MONOMIAL
    block = &#x27;plasma&#x27;
  []
  [exRate]
    order = CONSTANT
    family = MONOMIAL
    block = &#x27;plasma&#x27;
  []
  [swRate]
    order = CONSTANT
    family = MONOMIAL
    block = &#x27;plasma&#x27;
  []
  [deexRate]
    order = CONSTANT
    family = MONOMIAL
    block = &#x27;plasma&#x27;
  []
  [quRate]
    order = CONSTANT
    family = MONOMIAL
    block = &#x27;plasma&#x27;
  []
  [poolRate]
    order = CONSTANT
    family = MONOMIAL
    block = &#x27;plasma&#x27;
  []
  [TwoBRate]
    order = CONSTANT
    family = MONOMIAL
    block = &#x27;plasma&#x27;
  []
  [ThreeBRate]
    order = CONSTANT
    family = MONOMIAL
    block = &#x27;plasma&#x27;
  []

[]

[AuxKernels]
  #[emDeBug]
  #  type = DebugResidualAux
  #  variable = emDeBug
  #  debug_variable = em
  #[]
  #[Ar+_DeBug]
  #  type = DebugResidualAux
  #  variable = Ar+_DeBug
  #  debug_variable = Ar+
  #[]
  #[mean_enDeBug]
  #  type = DebugResidualAux
  #  variable = mean_enDeBug
  #  debug_variable = mean_en
  #[]
  #[Ar*_DeBug]
  #  type = DebugResidualAux
  #  variable = Ar*_DeBug
  #  debug_variable = Ar*
  #[]
  #[Potential_DeBug]
  #  type = DebugResidualAux
  #  variable = potential_DeBug
  #  debug_variable = potential
  #[]

  [emRate]
    type = ProcRateForRateCoeff
    variable = emRate
    v = em
    w = Ar
    reaction = &#x27;em + Ar -&gt; em + em + Ar+&#x27;
  []
  [exRate]
    type = ProcRateForRateCoeff
    variable = exRate
    v = em
    w = Ar*
    reaction = &#x27;em + Ar -&gt; em + Ar*&#x27;
  []
  [swRate]
    type = ProcRateForRateCoeff
    variable = swRate
    v = em
    w = Ar*
    reaction = &#x27;em + Ar* -&gt; em + em + Ar+&#x27;
  []
  [deexRate]
    type = ProcRateForRateCoeff
    variable = deexRate
    v = em
    w = Ar*
    reaction = &#x27;em + Ar* -&gt; em + Ar&#x27;
  []
  [quRate]
    type = ProcRateForRateCoeff
    variable = quRate
    v = em
    w = Ar*
    reaction = &#x27;em + Ar* -&gt; em + Ar_r&#x27;
  []
  [poolRate]
    type = ProcRateForRateCoeff
    variable = poolRate
    v = Ar*
    w = Ar*
    reaction = &#x27;Ar* + Ar* -&gt; Ar+ + Ar + em&#x27;
  []
  [TwoBRate]
    type = ProcRateForRateCoeff
    variable = TwoBRate
    v = Ar*
    w = Ar
    reaction = &#x27;Ar* + Ar -&gt; Ar + Ar&#x27;
  []
  [ThreeBRate]
    type = ProcRateForRateCoeffThreeBody
    variable = ThreeBRate
    v = Ar*
    w = Ar
    x = Ar
    reaction = &#x27;Ar* + Ar + Ar -&gt; Ar_2 + Ar&#x27;
  []
  [Te]
    type = ElectronTemperature
    variable = Te
    electron_density = em
    mean_en = mean_en
  []
  [x_g]
    type = Position
    variable = x
    position_units = ${dom0Scale}
  []
  [x_ng]
    type = Position
    variable = x_node
    position_units = ${dom0Scale}
  []

  [y_g]
    type = Position
    variable = y
    position_units = ${dom0Scale}
  []
  [y_ng]
    type = Position
    variable = y_node
    position_units = ${dom0Scale}
  []

  [em_lin]
    type = DensityMoles
    variable = em_lin
    density_log = em
  []
  [Ar+_lin]
    type = DensityMoles
    variable = Ar+_lin
    density_log = Ar+
  []
  [Ar*_lin]
    type = DensityMoles
    variable = Ar*_lin
    density_log = Ar*
  []

  [Ar_val]
    type = ConstantAux
    variable = Ar
    # value = 3.22e2
    value = -5.231208
    execute_on = INITIAL
  []

  [Efieldx_calc]
    type = Efield
    component = 0
    variable = Efieldx
    position_units = ${dom0Scale}
  []
  [Efieldy_calc]
    type = Efield
    component = 1
    variable = Efieldy
    position_units = ${dom0Scale}
  []

  [Current_em]
    type = ADCurrent
    density_log = em
    variable = Current_em
    art_diff = false
    block = &#x27;plasma&#x27;
    position_units = ${dom0Scale}
  []
  [Current_Ar]
    type = ADCurrent
    field_property_name = field_ion
    density_log = Ar+
    variable = Current_Ar
    art_diff = false
    block = &#x27;plasma&#x27;
    position_units = ${dom0Scale}
  []

[]

[BCs]
  #Voltage Boundary Condition, same as in paper
  [potential_top_plate]
    type = FunctionDirichletBC
    variable = potential
    boundary = &#x27;Top_Electrode&#x27;
    function = potential_top_bc_func
    preset = false
  []
  [potential_bottom_plate]
    type = FunctionDirichletBC
    variable = potential
    boundary = &#x27;Bottom_Electrode&#x27;
    function = potential_bottom_bc_func
    preset = false
  []
  [potential_dirichlet_bottom_plate]
    type = DirichletBC
    variable = potential
    boundary = &#x27;Walls&#x27;
    value = 0
    preset = false
  []
  [potential_Dielectric]
    type = EconomouDielectricBC
    variable = potential
    boundary = &#x27;Top_Insulator Bottom_Insulator&#x27;
    electrons = em
    ions = Ar+
    ion_potentials = potential_ion
    electron_energy = mean_en
    dielectric_constant = 1.859382e-11
    thickness = 0.0127
    emission_coeffs = 0.01
    position_units = ${dom0Scale}
  []

  #New Boundary conditions for electons, same as in paper
  [em_physical_diffusion]
    type = SakiyamaElectronDiffusionBC
    variable = em
    electron_energy = mean_en
    boundary = &#x27;Top_Electrode Bottom_Electrode Top_Insulator Bottom_Insulator Walls&#x27;
    position_units = ${dom0Scale}
  []
  [em_Ar+_second_emissions]
    type = SakiyamaSecondaryElectronBC
    variable = em
    field_property_name = field_ion
    ions = Ar+
    emission_coeffs = 0.01
    boundary = &#x27;Top_Electrode Bottom_Electrode Top_Insulator Bottom_Insulator Walls&#x27;
    position_units = ${dom0Scale}
  []

  #New Boundary conditions for ions, should be the same as in paper
  [Ar+_physical_advection]
    type = SakiyamaIonAdvectionBC
    variable = Ar+
    field_property_name = field_ion
    boundary = &#x27;Top_Electrode Bottom_Electrode Top_Insulator Bottom_Insulator Walls&#x27;
    position_units = ${dom0Scale}
  []

  #New Boundary conditions for ions, should be the same as in paper
  #(except the metastables are not set to zero, since Zapdos uses log form)
  [Ar*_physical_diffusion]
    type = LogDensityDirichletBC
    variable = Ar*
    boundary = &#x27;Top_Electrode Bottom_Electrode Top_Insulator Bottom_Insulator Walls&#x27;
    value = 100
  []

  #New Boundary conditions for mean energy, should be the same as in paper
  [mean_en_physical_diffusion]
    type = SakiyamaEnergyDiffusionBC
    variable = mean_en
    electrons = em
    boundary = &#x27;Top_Electrode Bottom_Electrode Top_Insulator Bottom_Insulator Walls&#x27;
    position_units = ${dom0Scale}
  []
  [mean_en_Ar+_second_emissions]
    type = SakiyamaEnergySecondaryElectronBC
    variable = mean_en
    electrons = em
    ions = Ar+
    field_property_name = field_ion
    Tse_equal_Te = true
    emission_coeffs = 0.01
    boundary = &#x27;Top_Electrode Bottom_Electrode Top_Insulator Bottom_Insulator Walls&#x27;
    position_units = ${dom0Scale}
  []

[]

[ICs]
  [em_ic]
    type = FunctionIC
    variable = em
    function = density_ic_func
  []
  [Ar+_ic]
    type = FunctionIC
    variable = Ar+
    function = density_ic_func
  []
  [Ar*_ic]
    type = FunctionIC
    variable = Ar*
    function = meta_density_ic_func
  []
  [mean_en_ic]
    type = FunctionIC
    variable = mean_en
    function = energy_density_ic_func
  []

  [potential_ic]
    type = FunctionIC
    variable = potential
    function = potential_ic_func
  []
[]

[Functions]
  [potential_top_bc_func]
    type = ParsedFunction
    expression = &#x27;50*sin(2*3.1415926*13.56e6*t)&#x27;
  []
  [potential_bottom_bc_func]
    type = ParsedFunction
    expression = &#x27;-50*sin(2*3.1415926*13.56e6*t)&#x27;
  []
  [potential_ic_func]
    type = ParsedFunction
    expression = 0
  []
  [density_ic_func]
    type = ParsedFunction
    expression = &#x27;log((1e14)/6.022e23)&#x27;
  []
  [meta_density_ic_func]
    type = ParsedFunction
    expression = &#x27;log((1e16)/6.022e23)&#x27;
  []
  [energy_density_ic_func]
    type = ParsedFunction
    expression = &#x27;log((3./2.) * 4) + log((1e14)/6.022e23)&#x27;
  []
[]

[Materials]
  [field_solver]
    type = FieldSolverMaterial
    potential = potential
  []
  [field_solver_ion]
    type = FieldSolverMaterial
    potential = potential_ion
    property_name = field_ion
  []
  [GasBasics]
    type = GasElectronMoments
    interp_trans_coeffs = true
    interp_elastic_coeff = false
    ramp_trans_coeffs = false
    user_p_gas = 133.322
    em = em
    mean_en = mean_en
    user_se_coeff = 0.00
    property_tables_file = Argon_reactions_paper_RateCoefficients/electron_moments.txt
  []
  [gas_species_0]
    type = ADHeavySpecies
    heavy_species_name = Ar+
    heavy_species_mass = 6.64e-26
    heavy_species_charge = 1.0
    mobility = 1.44409938
    diffusivity = 6.428571e-2
  []
  [gas_species_1]
    type = ADHeavySpecies
    heavy_species_name = Ar*
    heavy_species_mass = 6.64e-26
    heavy_species_charge = 0.0
    diffusivity = 7.515528e-2
  []
  [gas_species_2]
    type = ADHeavySpecies
    heavy_species_name = Ar
    heavy_species_mass = 6.64e-26
    heavy_species_charge = 0.0
  []
  [reaction_00]
    type = ZapdosEEDFRateConstant
    mean_energy = mean_en
    property_file = &#x27;Argon_reactions_paper_RateCoefficients/ar_elastic.txt&#x27;
    reaction = &#x27;em + Ar -&gt; em + Ar&#x27;
    electrons = em
  []
  [reaction_0]
    type = ZapdosEEDFRateConstant
    property_file = &#x27;Argon_reactions_paper_RateCoefficients/ar_excitation.txt&#x27;
    reaction = &#x27;em + Ar -&gt; em + Ar*&#x27;
    mean_energy = mean_en
    electrons = em
  []
  [reaction_1]
    type = ZapdosEEDFRateConstant
    property_file = &#x27;Argon_reactions_paper_RateCoefficients/ar_ionization.txt&#x27;
    reaction = &#x27;em + Ar -&gt; em + em + Ar+&#x27;
    mean_energy = mean_en
    electrons = em
  []
  [reaction_2]
    type = ZapdosEEDFRateConstant
    reaction = &#x27;em + Ar* -&gt; em + Ar&#x27;
    property_file = &#x27;Argon_reactions_paper_RateCoefficients/ar_deexcitation.txt&#x27;
    mean_energy = mean_en
    electrons = em
  []
  [reaction_3]
    type = ZapdosEEDFRateConstant
    reaction = &#x27;em + Ar* -&gt; em + em + Ar+&#x27;
    property_file = &#x27;Argon_reactions_paper_RateCoefficients/ar_excited_ionization.txt&#x27;
    mean_energy = mean_en
    electrons = em
  []
  [reaction_4]
    type = GenericRateConstant
    reaction = &#x27;em + Ar* -&gt; em + Ar_r&#x27;
    #reaction_rate_value = 2e-13
    reaction_rate_value = 1.2044e11
  []
  [reaction_5]
    type = GenericRateConstant
    reaction = &#x27;Ar* + Ar* -&gt; Ar+ + Ar + em&#x27;
    #reaction_rate_value = 6.2e-16
    reaction_rate_value = 373364000
  []
  [reaction_6]
    type = GenericRateConstant
    reaction = &#x27;Ar* + Ar -&gt; Ar + Ar&#x27;
    #reaction_rate_value = 3e-21
    reaction_rate_value = 1806.6
  []
  [reaction_7]
    type = GenericRateConstant
    reaction = &#x27;Ar* + Ar + Ar -&gt; Ar_2 + Ar&#x27;
    #reaction_rate_value = 1.1e-42
    reaction_rate_value = 398909.324
  []
[]

#New postprocessor that calculates the inverse of the plasma frequency
[Postprocessors]
  [InversePlasmaFreq]
    type = PlasmaFrequencyInverse
    variable = em
    use_moles = true
    execute_on = &#x27;INITIAL TIMESTEP_BEGIN&#x27;
  []
[]

[Preconditioning]
  active = &#x27;smp&#x27;
  [smp]
    type = SMP
    full = true
  []

  [fdp]
    type = FDP
    full = true
  []
[]

[Executioner]
  type = Transient
  #end_time = 7.4e-3
  end_time = 1e-7
  dtmax = 1e-9
  petsc_options = &#x27;-snes_converged_reason -snes_linesearch_monitor&#x27;
  solve_type = NEWTON
  petsc_options_iname = &#x27;-pc_type -pc_factor_shift_type -pc_factor_shift_amount -ksp_type -snes_linesearch_minlambda&#x27;
  petsc_options_value = &#x27;lu NONZERO 1.e-10 fgmres 1e-3&#x27;
  nl_rel_tol = 1e-12
  #nl_abs_tol = 7.6e-5
  dtmin = 1e-14
  l_max_its = 20

  #Time steps based on the inverse of the plasma frequency
  #[TimeSteppers]
  #  [Postprocessor]
  #    type = PostprocessorDT
  #    postprocessor = InversePlasmaFreq
  #    scale = 0.1
  #  []
  #[]
[]

[Outputs]
  perf_graph = true
  [out]
    type = Exodus
  []
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="e62bc260-352a-44a3-8ce4-9e7abe6ee19f"><div class="modal-content"><h4>(test/tests/mms/bcs/2D_ElectronBC.i)</h4><pre style="max-height:350px;"><code class="language-moose">[Mesh]
  [geo]
    type = FileMeshGenerator
    file = &#x27;2D_ElectronBC_IC_out.e&#x27;
    use_for_exodus_restart = true
  []
[]

[Problem]
  type = FEProblem
[]

[Variables]
  [em]
    initial_from_file_var = em
  []
  [ion]
    initial_from_file_var = ion
  []
  [mean_en]
    initial_from_file_var = mean_en
  []

  [Ex]
    initial_from_file_var = Ex
  []
  [Ey]
    initial_from_file_var = Ey
  []

  [potential]
    initial_from_file_var = potential
  []
[]

[Kernels]
#Electron Equations
  [em_time_derivative]
    type = TimeDerivativeLog
    variable = em
  []
  [em_diffusion]
    type = CoeffDiffusion
    variable = em
    position_units = 1.0
  []
  [em_advection]
    type = EFieldAdvection
    variable = em
    position_units = 1.0
  []
  [em_source]
    type = BodyForce
    variable = em
    function = &#x27;em_source&#x27;
  []

#Ion Equations
  [ion_time_derivative]
    type = TimeDerivativeLog
    variable = ion
  []
  [ion_diffusion]
    type = CoeffDiffusion
    variable = ion
    position_units = 1.0
  []
  [ion_advection]
    type = EffectiveEFieldAdvection
    variable = ion
    u = Ex
    v = Ey
    position_units = 1.0
  []
  [ion_source]
    type = BodyForce
    variable = ion
    function = &#x27;ion_source&#x27;
  []


#Eff. Efield
  [EffEfield_X_time_deriv]
    type = TimeDerivative
    variable = Ex
  []
  [EffEfield_X_diffusion]
    type = MatDiffusion
    diffusivity = diffEx
    variable = Ex
  []
  [EffEfield_X_source]
    type = BodyForce
    variable = Ex
    function = &#x27;Ex_source&#x27;
  []
  [EffEfield_Y_time_deriv]
    type = TimeDerivative
    variable = Ey
  []
  [EffEfield_Y_diffusion]
    type = MatDiffusion
    diffusivity = diffEy
    variable = Ey
  []
  [EffEfield_Y_source]
    type = BodyForce
    variable = Ey
    function = &#x27;Ey_source&#x27;
  []

  #Potential
  [Potential_time_deriv]
    type = TimeDerivative
    variable = potential
  []
  [Potential_diffusion]
    type = MatDiffusion
    diffusivity = diffpotential
    variable = potential
  []
  [Potential_source]
    type = BodyForce
    variable = potential
    function = &#x27;potential_source&#x27;
  []

#Electron Energy Equations
  [mean_en_time_deriv]
    type = TimeDerivativeLog
    variable = mean_en
  []
  [mean_en_diffusion]
    type = CoeffDiffusion
    variable = mean_en
    position_units = 1.0
  []
  [mean_en_source]
    type = BodyForce
    variable = mean_en
    function = &#x27;energy_source&#x27;
  []
[]

[AuxVariables]
  [mean_en_sol]
  []

  [em_sol]
  []

  [ion_sol]
  []

  [Ex_sol]
  []
  [Ey_sol]
  []

  [potential_sol]
  []
[]

[AuxKernels]
  [mean_en_sol]
    type = FunctionAux
    variable = mean_en_sol
    function = mean_en_fun
  []

  [em_sol]
    type = FunctionAux
    variable = em_sol
    function = em_fun
  []

  [ion_sol]
    type = FunctionAux
    variable = ion_sol
    function = ion_fun
  []

  [Ex_sol]
    type = FunctionAux
    variable = Ex_sol
    function = Ex_fun
  []
  [Ey_sol]
    type = FunctionAux
    variable = Ey_sol
    function = Ey_fun
  []

  [potential_sol]
    type = FunctionAux
    variable = potential_sol
    function = potential_fun
  []
[]

[Functions]
#Material Variables
  [massem]
    type = ConstantFunction
    value = 1.0
  []
  #Electron diffusion coeff.
  [diffem]
    type = ConstantFunction
    value = 0.05
  []
  [muem]
    type = ConstantFunction
    value = 0.01
  []
  #Electron energy mobility coeff.
  [diffmean_en]
    type = ConstantFunction
    value = 0.05
  []
  #Ion diffusion coeff.
  [diffion]
    type = ParsedFunction
    vars = diffem
    vals = diffem
    value = diffem
  []
  [muion]
    type = ParsedFunction
    vars = muem
    vals = muem
    value = muem
  []
  [N_A]
    type = ConstantFunction
    value = 1.0
  []
  [ee]
    type = ConstantFunction
    value = 1.0
  []
  [diffpotential]
    type = ConstantFunction
    value = 0.25
  []


#Manufactured Solutions
  #The manufactured electron density solution
  [em_fun]
    type = ParsedFunction
    vars = &#x27;N_A&#x27;
    vals = &#x27;N_A&#x27;
    value = &#x27;log((sin(pi*y) + 0.2*sin(2*pi*t)*cos(pi*y) + 1.0 + sin(pi*x)) / N_A)&#x27;
  []
  #The manufactured ion density solution
  [ion_fun]
    type = ParsedFunction
    vars = &#x27;N_A&#x27;
    vals = &#x27;N_A&#x27;
    value = &#x27;log((sin(pi*y) + 0.2*sin(2*pi*t)*cos(pi*y) + 1.0 + sin(pi*x)) / N_A)&#x27;
  []
  #The manufactured electron energy solution
  [mean_en_fun]
    type = ParsedFunction
    vars = &#x27;ee N_A diffpotential diffem muem massem diffmean_en diffion muion&#x27;
    vals = &#x27;ee N_A diffpotential diffem muem massem diffmean_en diffion muion&#x27;
    value = &#x27;log(((3*massem*pi*(4*pi*diffem + 8*muem*pi*(sin(pi*t) + 1)*(sin(pi*x) + sin(pi*y) +
                 (cos(pi*y)*sin(2*pi*t))/5 + 1))^2)/(16*ee*(sin(pi*x) + sin(pi*y) +
                 (cos(pi*y)*sin(2*pi*t))/5 + 1))) / N_A)&#x27;
  []
  #The manufactured eff. Efield solution
  [Ex_fun]
    type = ParsedFunction
    vars = &#x27;ee N_A diffpotential diffem muem massem diffmean_en diffion muion&#x27;
    vals = &#x27;ee N_A diffpotential diffem muem massem diffmean_en diffion muion&#x27;
    value = &#x27;-pi*cos(pi*x)*(sin(pi*t) + 1)&#x27;
  []
  [Ey_fun]
    type = ParsedFunction
    vars = &#x27;ee N_A diffpotential diffem muem massem diffmean_en diffion muion&#x27;
    vals = &#x27;ee N_A diffpotential diffem muem massem diffmean_en diffion muion&#x27;
    value = &#x27;-pi*cos(pi*y)*(sin(pi*t) + 1)&#x27;
  []
  #The manufactured potential solution
  [potential_fun]
    type = ParsedFunction
    vars = &#x27;ee N_A diffpotential diffem muem massem diffmean_en diffion muion&#x27;
    vals = &#x27;ee N_A diffpotential diffem muem massem diffmean_en diffion muion&#x27;
    value = &#x27;-(sin(pi*t) + 1.0)*(sin(pi*y) + sin(pi*x))&#x27;
  []

#Source Terms in moles
  #The electron source term.
  [em_source]
    type = ParsedFunction
    vars = &#x27;ee N_A diffpotential diffem muem massem diffmean_en diffion muion&#x27;
    vals = &#x27;ee N_A diffpotential diffem muem massem diffmean_en diffion muion&#x27;
    value = &#x27;(diffem*pi^2*sin(pi*x) + (diffem*pi^2*(5*sin(pi*y) +
              cos(pi*y)*sin(2*pi*t)))/5 + (2*pi*cos(2*pi*t)*cos(pi*y))/5 +
              (muem*pi^2*(sin(pi*t) + 1)*(5*sin(pi*x) + 5*sin(pi*y) + 10*sin(pi*x)*sin(pi*y) -
              10*cos(pi*x)^2 - 10*cos(pi*y)^2 + cos(pi*y)*sin(2*pi*t)*sin(pi*x) +
              2*cos(pi*y)*sin(2*pi*t)*sin(pi*y) + 10))/5) / N_A&#x27;
  []
  #The ion source term.
  [ion_source]
    type = ParsedFunction
    vars = &#x27;ee N_A diffpotential diffem muem massem diffmean_en diffion muion&#x27;
    vals = &#x27;ee N_A diffpotential diffem muem massem diffmean_en diffion muion&#x27;
    value = &#x27;(diffion*pi^2*sin(pi*x) + (diffion*pi^2*(5*sin(pi*y) + cos(pi*y)*sin(2*pi*t)))/5 +
              (2*pi*cos(2*pi*t)*cos(pi*y))/5 + (muion*pi^2*(sin(pi*t) + 1)*(5*sin(pi*x) + 5*sin(pi*y) +
              10*sin(pi*x)*sin(pi*y) - 10*cos(pi*x)^2 - 10*cos(pi*y)^2 + cos(pi*y)*sin(2*pi*t)*sin(pi*x) +
              2*cos(pi*y)*sin(2*pi*t)*sin(pi*y) + 10))/5) / N_A&#x27;
  []
  [energy_source]
    type = ParsedFunction
    vars = &#x27;ee N_A diffpotential diffem muem massem diffmean_en diffion muion&#x27;
    vals = &#x27;ee N_A diffpotential diffem muem massem diffmean_en diffion muion&#x27;
    value = &#x27;((3*massem*pi*(8*muem*pi^2*cos(pi*t)*(sin(pi*x) + sin(pi*y) + (cos(pi*y)*sin(2*pi*t))/5 + 1) +
              (16*muem*pi^2*cos(2*pi*t)*cos(pi*y)*(sin(pi*t) + 1))/5)*(4*pi*diffem + 8*muem*pi*(sin(pi*t) + 1)*(sin(pi*x) +
              sin(pi*y) + (cos(pi*y)*sin(2*pi*t))/5 + 1)))/(8*ee*(sin(pi*x) + sin(pi*y) + (cos(pi*y)*sin(2*pi*t))/5 + 1)) -
              diffmean_en*((3*massem*pi^3*sin(pi*x)*(4*pi*diffem + 8*muem*pi*(sin(pi*t) + 1)*(sin(pi*x) + sin(pi*y) +
              (cos(pi*y)*sin(2*pi*t))/5 + 1))^2)/(16*ee*(sin(x*pi) + sin(y*pi) + (cos(y*pi)*sin(2*t*pi))/5 + 1)^2) +
              (3*massem*pi^3*cos(pi*x)^2*(4*pi*diffem + 8*muem*pi*(sin(pi*t) + 1)*(sin(pi*x) + sin(pi*y) +
              (cos(pi*y)*sin(2*pi*t))/5 + 1))^2)/(8*ee*(sin(x*pi) + sin(y*pi) + (cos(y*pi)*sin(2*t*pi))/5 + 1)^3) +
              (24*massem*muem^2*pi^5*cos(pi*x)^2*(sin(pi*t) + 1)^2)/(ee*(sin(pi*x) + sin(pi*y) + (cos(pi*y)*sin(2*pi*t))/5 + 1)) -
              (3*massem*muem*pi^4*sin(pi*x)*(4*pi*diffem + 8*muem*pi*(sin(pi*t) + 1)*(sin(pi*x) + sin(pi*y) +
              (cos(pi*y)*sin(2*pi*t))/5 + 1))*(sin(pi*t) + 1))/(ee*(sin(pi*x) + sin(pi*y) + (cos(pi*y)*sin(2*pi*t))/5 + 1)) -
              (6*massem*muem*pi^4*cos(pi*x)^2*(4*pi*diffem + 8*muem*pi*(sin(pi*t) + 1)*(sin(pi*x) + sin(pi*y) +
              (cos(pi*y)*sin(2*pi*t))/5 + 1))*(sin(pi*t) + 1))/(ee*(sin(x*pi) + sin(y*pi) + (cos(y*pi)*sin(2*t*pi))/5 + 1)^2)) -
              diffmean_en*((3*massem*pi*(pi*cos(pi*y) - (pi*sin(2*pi*t)*sin(pi*y))/5)^2*(4*pi*diffem +
              8*muem*pi*(sin(pi*t) + 1)*(sin(pi*x) + sin(pi*y) + (cos(pi*y)*sin(2*pi*t))/5 + 1))^2)/(8*ee*(sin(x*pi) + sin(y*pi) +
              (cos(y*pi)*sin(2*t*pi))/5 + 1)^3) + (3*massem*pi*(pi^2*sin(pi*y) + (pi^2*cos(pi*y)*sin(2*pi*t))/5)*(4*pi*diffem +
              8*muem*pi*(sin(pi*t) + 1)*(sin(pi*x) + sin(pi*y) + (cos(pi*y)*sin(2*pi*t))/5 + 1))^2)/(16*ee*(sin(x*pi) +
              sin(y*pi) + (cos(y*pi)*sin(2*t*pi))/5 + 1)^2) + (24*massem*muem^2*pi^3*(pi*cos(pi*y) -
              (pi*sin(2*pi*t)*sin(pi*y))/5)^2*(sin(pi*t) + 1)^2)/(ee*(sin(pi*x) + sin(pi*y) + (cos(pi*y)*sin(2*pi*t))/5 + 1)) -
              (6*massem*muem*pi^2*(pi*cos(pi*y) - (pi*sin(2*pi*t)*sin(pi*y))/5)^2*(4*pi*diffem + 8*muem*pi*(sin(pi*t) + 1)*(sin(pi*x) +
              sin(pi*y) + (cos(pi*y)*sin(2*pi*t))/5 + 1))*(sin(pi*t) + 1))/(ee*(sin(x*pi) + sin(y*pi) + (cos(y*pi)*sin(2*t*pi))/5 + 1)^2) -
              (3*massem*muem*pi^2*(pi^2*sin(pi*y) + (pi^2*cos(pi*y)*sin(2*pi*t))/5)*(4*pi*diffem +
              8*muem*pi*(sin(pi*t) + 1)*(sin(pi*x) + sin(pi*y) + (cos(pi*y)*sin(2*pi*t))/5 + 1))*(sin(pi*t) + 1))/(ee*(sin(pi*x) + sin(pi*y) +
              (cos(pi*y)*sin(2*pi*t))/5 + 1))) - (3*massem*pi^2*cos(2*pi*t)*cos(pi*y)*(4*pi*diffem + 8*muem*pi*(sin(pi*t) + 1)*(sin(pi*x) +
              sin(pi*y) + (cos(pi*y)*sin(2*pi*t))/5 + 1))^2)/(40*ee*(sin(x*pi) + sin(y*pi) + (cos(y*pi)*sin(2*t*pi))/5 + 1)^2)) / N_A&#x27;
  []

  #The Ex source term.
  [Ex_source]
    type = ParsedFunction
    vars = &#x27;ee N_A diffpotential diffem muem massem diffmean_en diffion muion&#x27;
    vals = &#x27;ee N_A diffpotential diffem muem massem diffmean_en diffion muion&#x27;
    value = &#x27;-pi^2*cos(pi*t)*cos(pi*x) - diffpotential*pi^3*cos(pi*x)*(sin(pi*t) + 1)&#x27;
  []
  [Ey_source]
    type = ParsedFunction
    vars = &#x27;ee N_A diffpotential diffem muem massem diffmean_en diffion muion&#x27;
    vals = &#x27;ee N_A diffpotential diffem muem massem diffmean_en diffion muion&#x27;
    value = &#x27;-pi^2*cos(pi*t)*cos(pi*y) - diffpotential*pi^3*cos(pi*y)*(sin(pi*t) + 1)&#x27;
  []

  [potential_source]
    type = ParsedFunction
    vars = &#x27;ee N_A diffpotential diffem muem massem diffmean_en diffion muion&#x27;
    vals = &#x27;ee N_A diffpotential diffem muem massem diffmean_en diffion muion&#x27;
    value = &#x27;-pi*cos(pi*t)*(sin(pi*x) + sin(pi*y)) -
             diffpotential*pi^2*sin(pi*x)*(sin(pi*t) + 1) -
             diffpotential*pi^2*sin(pi*y)*(sin(pi*t) + 1)&#x27;
  []

  [em_ICs]
    type = ParsedFunction
    vars = &#x27;N_A&#x27;
    vals = &#x27;N_A&#x27;
    value = &#x27;log((3.0 + sin(pi/2*x)) / N_A)&#x27;
  []
  [ion_ICs]
    type = ParsedFunction
    vars = &#x27;N_A&#x27;
    vals = &#x27;N_A&#x27;
    value = &#x27;log((3.0 + sin(pi/2*x)) / N_A)&#x27;
  []
  [mean_en_ICs]
    type = ParsedFunction
    vars = &#x27;em_ICs&#x27;
    vals = &#x27;em_ICs&#x27;
    value = &#x27;log(3./2.) + em_ICs&#x27;
  []

  [em_left_Flux_BC]
    type = ParsedFunction
    vars = &#x27;ee N_A diffpotential diffem muem massem diffmean_en diffion muion&#x27;
    vals = &#x27;ee N_A diffpotential diffem muem massem diffmean_en diffion muion&#x27;
    value = &#x27;(-diffem*pi*cos(pi*x) - muem*pi*cos(pi*x)*(sin(pi*t) + 1)*(sin(pi*x) +
              sin(pi*y) + (cos(pi*y)*sin(2*pi*t))/5 + 1)) / N_A&#x27;
  []
  [em_down_Flux_BC]
    type = ParsedFunction
    vars = &#x27;ee N_A diffpotential diffem muem massem diffmean_en diffion muion&#x27;
    vals = &#x27;ee N_A diffpotential diffem muem massem diffmean_en diffion muion&#x27;
    value = &#x27;(-(diffem*pi*(5*cos(pi*y) - sin(2*pi*t)*sin(pi*y)))/5 -
              muem*pi*cos(pi*y)*(sin(pi*t) + 1)*(sin(pi*x) + sin(pi*y) +
              (cos(pi*y)*sin(2*pi*t))/5 + 1)) / N_A&#x27;
  []
[]

[BCs]
  #[em_left_BC]
  #  type = FunctionDirichletBC
  #  variable = em
  #  function = &#x27;em_fun&#x27;
  #  boundary = 3
  #  preset = true
  #[]
  #[em_left_BC]
  #  type = FunctionNeumannBC
  #  variable = em
  #  function = &#x27;em_left_Flux_BC&#x27;
  #  boundary = 3
  #  preset = true
  #[]
  [em_physical_diffusion_left]
    type = SakiyamaElectronDiffusionBC
    variable = em
    electron_energy = mean_en
    boundary = 3
    position_units = 1.0
  []
  [em_Ar+_second_emissions_left]
    type = SakiyamaSecondaryElectronWithEffEfieldBC
    variable = em
    Ex = Ex
    Ey = Ey
    ions = ion
    emission_coeffs = &#x27;users_gamma&#x27;
    boundary = 3
    position_units = 1.0
  []

  [em_right_BC]
    type = FunctionDirichletBC
    variable = em
    function = &#x27;em_fun&#x27;
    boundary = 1
    preset = true
  []

  #[em_down_BC]
  #  type = FunctionDirichletBC
  #  variable = em
  #  function = &#x27;em_fun&#x27;
  #  boundary = 0
  #  preset = true
  #[]
  #[em_down_BC]
  #  type = FunctionNeumannBC
  #  variable = em
  #  function = &#x27;em_down_Flux_BC&#x27;
  #  boundary = 0
  #  preset = true
  #[]
  [em_physical_diffusion_down]
    type = SakiyamaElectronDiffusionBC
    variable = em
    electron_energy = mean_en
    boundary = 0
    position_units = 1.0
  []
  [em_Ar+_second_emissions_down]
    type = SakiyamaSecondaryElectronWithEffEfieldBC
    variable = em
    Ex = Ex
    Ey = Ey
    ions = ion
    emission_coeffs = &#x27;users_gamma&#x27;
    boundary = 0
    position_units = 1.0
  []

  [em_up_BC]
    type = FunctionDirichletBC
    variable = em
    function = &#x27;em_fun&#x27;
    boundary = 2
    preset = true
  []

  [ion_BC]
    type = FunctionDirichletBC
    variable = ion
    function = &#x27;ion_fun&#x27;
    boundary = &#x27;0 1 2 3&#x27;
    preset = true
  []

  [energy_BC]
    type = FunctionDirichletBC
    variable = mean_en
    function = &#x27;mean_en_fun&#x27;
    boundary = &#x27;0 1 2 3&#x27;
    preset = true
  []

  [Ex_BC]
    type = FunctionDirichletBC
    variable = Ex
    function = &#x27;Ex_fun&#x27;
    boundary = &#x27;0 1 2 3&#x27;
    preset = true
  []

  [Ey_BC]
    type = FunctionDirichletBC
    variable = Ey
    function = &#x27;Ey_fun&#x27;
    boundary = &#x27;0 1 2 3&#x27;
    preset = true
  []

  [potential_BC]
    type = FunctionDirichletBC
    variable = potential
    function = &#x27;potential_fun&#x27;
    boundary = &#x27;0 1 2 3&#x27;
    preset = true
  []
[]

[Materials]
  [field_solver]
    type = FieldSolverMaterial
    potential = potential
  []
  [Material_Coeff]
    type = GenericFunctionMaterial
    prop_names =  &#x27;e  N_A  massem diffpotential  diffEx         diffEy&#x27;
    prop_values = &#x27;ee N_A  massem diffpotential  diffpotential  diffpotential &#x27;
  []
  [ADMaterial_Coeff_Set1]
    type = ADGenericFunctionMaterial
    prop_names =  &#x27;diffion  muion  diffem  muem  diffmean_en&#x27;
    prop_values = &#x27;diffion  muion  diffem  muem  diffmean_en&#x27;
  []
  [Charge_Signs]
    type = GenericConstantMaterial
    prop_names =  &#x27;sgnem  sgnion  sgnmean_en&#x27;
    prop_values = &#x27;-1.0   1.0     -1.0&#x27;
  []
  [emission_coeffs]
    type = ADGenericConstantMaterial
    prop_names = &#x27;users_gamma&#x27;
    prop_values = &#x27;1.0&#x27;
  []
[]

[Postprocessors]
  [em_l2Error]
    type = ElementL2Error
    variable = em
    function = em_fun
  []
  [ion_l2Error]
    type = ElementL2Error
    variable = ion
    function = ion_fun
  []
  [mean_en_l2Error]
    type = ElementL2Error
    variable = mean_en
    function = mean_en_fun
  []

  [Ex_l2Error]
    type = ElementL2Error
    variable = Ex
    function = Ex_fun
  []
  [Ey_l2Error]
    type = ElementL2Error
    variable = Ey
    function = Ey_fun
  []

  [potential_l2Error]
    type = ElementL2Error
    variable = potential
    function = potential_fun
  []

  [h]
    type = AverageElementSize
  []
[]

[Preconditioning]
  active = &#x27;smp&#x27;
  [smp]
    type = SMP
    full = true
  []

  [fdp]
    type = FDP
    full = true
  []
[]

[Executioner]
  type = Transient
  start_time = 50
  end_time = 51
  # dt = 0.008
  dt = 0.02

  automatic_scaling = true
  compute_scaling_once = false
  petsc_options = &#x27;-snes_converged_reason -snes_linesearch_monitor&#x27;
  solve_type = NEWTON
  line_search = none
  petsc_options_iname = &#x27;-pc_type -pc_factor_shift_type -pc_factor_shift_amount&#x27;
  petsc_options_value = &#x27;lu NONZERO 1.e-10&#x27;

  scheme = bdf2

  nl_abs_tol = 1e-13
[]

[Outputs]
  perf_graph = true
  [out]
    type = Exodus
    interval = 10
  []
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="d7c93497-dfb8-4995-881d-45927b2600b6"><div class="modal-content"><h4>(test/tests/mms/bcs/2D_ElectronBC_NegivateOutWardFacingEfield.i)</h4><pre style="max-height:350px;"><code class="language-moose">[Mesh]
  [geo]
    type = FileMeshGenerator
    file = &#x27;2D_ElectronBC_NegivateOutWardFacingEfield_IC_out.e&#x27;
    use_for_exodus_restart = true
  []
[]

[Problem]
  type = FEProblem
[]

[Variables]
  [em]
    initial_from_file_var = em
  []
  [ion]
    initial_from_file_var = ion
  []
  [mean_en]
    initial_from_file_var = mean_en
  []

  [Ex]
    initial_from_file_var = Ex
  []
  [Ey]
    initial_from_file_var = Ey
  []

  [potential]
    initial_from_file_var = potential
  []
[]

[Kernels]
#Electron Equations
  [em_time_derivative]
    type = TimeDerivativeLog
    variable = em
  []
  [em_diffusion]
    type = CoeffDiffusion
    variable = em
    position_units = 1.0
  []
  [em_advection]
    type = EFieldAdvection
    variable = em
    position_units = 1.0
  []
  [em_source]
    type = BodyForce
    variable = em
    function = &#x27;em_source&#x27;
  []

#Ion Equations
  [ion_time_derivative]
    type = TimeDerivativeLog
    variable = ion
  []
  [ion_diffusion]
    type = CoeffDiffusion
    variable = ion
    position_units = 1.0
  []
  [ion_advection]
    type = EffectiveEFieldAdvection
    variable = ion
    u = Ex
    v = Ey
    position_units = 1.0
  []
  [ion_source]
    type = BodyForce
    variable = ion
    function = &#x27;ion_source&#x27;
  []


#Eff. Efield
  [EffEfield_X_time_deriv]
    type = TimeDerivative
    variable = Ex
  []
  [EffEfield_X_diffusion]
    type = MatDiffusion
    diffusivity = diffEx
    variable = Ex
  []
  [EffEfield_X_source]
    type = BodyForce
    variable = Ex
    function = &#x27;Ex_source&#x27;
  []
  [EffEfield_Y_time_deriv]
    type = TimeDerivative
    variable = Ey
  []
  [EffEfield_Y_diffusion]
    type = MatDiffusion
    diffusivity = diffEy
    variable = Ey
  []
  [EffEfield_Y_source]
    type = BodyForce
    variable = Ey
    function = &#x27;Ey_source&#x27;
  []

  #Potential
  [Potential_time_deriv]
    type = TimeDerivative
    variable = potential
  []
  [Potential_diffusion]
    type = MatDiffusion
    diffusivity = diffpotential
    variable = potential
  []
  [Potential_source]
    type = BodyForce
    variable = potential
    function = &#x27;potential_source&#x27;
  []

#Electron Energy Equations
  [mean_en_time_deriv]
    type = TimeDerivativeLog
    variable = mean_en
  []
  [mean_en_diffusion]
    type = CoeffDiffusion
    variable = mean_en
    position_units = 1.0
  []
  [mean_en_source]
    type = BodyForce
    variable = mean_en
    function = &#x27;energy_source&#x27;
  []
[]

[AuxVariables]
  [mean_en_sol]
  []

  [em_sol]
  []

  [ion_sol]
  []

  [Ex_sol]
  []
  [Ey_sol]
  []

  [potential_sol]
  []
[]

[AuxKernels]
  [mean_en_sol]
    type = FunctionAux
    variable = mean_en_sol
    function = mean_en_fun
  []

  [em_sol]
    type = FunctionAux
    variable = em_sol
    function = em_fun
  []

  [ion_sol]
    type = FunctionAux
    variable = ion_sol
    function = ion_fun
  []

  [Ex_sol]
    type = FunctionAux
    variable = Ex_sol
    function = Ex_fun
  []
  [Ey_sol]
    type = FunctionAux
    variable = Ey_sol
    function = Ey_fun
  []

  [potential_sol]
    type = FunctionAux
    variable = potential_sol
    function = potential_fun
  []
[]

[Functions]
#Material Variables
  [massem]
    type = ConstantFunction
    value = 1.0
  []
  #Electron diffusion coeff.
  [diffem]
    type = ConstantFunction
    value = 0.05
  []
  [muem]
    type = ConstantFunction
    value = 0.01
  []
  #Electron energy mobility coeff.
  [diffmean_en]
    type = ConstantFunction
    value = 0.05
  []
  #Ion diffusion coeff.
  [diffion]
    type = ParsedFunction
    vars = diffem
    vals = diffem
    value = diffem
  []
  [muion]
    type = ParsedFunction
    vars = muem
    vals = muem
    value = muem
  []
  [N_A]
    type = ConstantFunction
    value = 1.0
  []
  [ee]
    type = ConstantFunction
    value = 1.0
  []
  [diffpotential]
    type = ConstantFunction
    value = 0.25
  []


#Manufactured Solutions
  #The manufactured electron density solution
  [em_fun]
    type = ParsedFunction
    vars = &#x27;N_A&#x27;
    vals = &#x27;N_A&#x27;
    value = &#x27;log((sin(pi*y) + 0.2*sin(2*pi*t)*cos(pi*y) + 1.0 + sin(pi*x)) / N_A)&#x27;
  []
  #The manufactured ion density solution
  [ion_fun]
    type = ParsedFunction
    vars = &#x27;N_A&#x27;
    vals = &#x27;N_A&#x27;
    value = &#x27;log((sin(pi*y) + 0.2*sin(2*pi*t)*cos(pi*y) + 1.0 + sin(pi*x)) / N_A)&#x27;
  []
  #The manufactured electron energy solution
  [mean_en_fun]
    type = ParsedFunction
    vars = &#x27;ee N_A diffpotential diffem muem massem diffmean_en diffion muion&#x27;
    vals = &#x27;ee N_A diffpotential diffem muem massem diffmean_en diffion muion&#x27;
    value = &#x27;log(((3*massem*pi*(4*pi*diffem + 4*muem*pi*(sin(pi*t) + 1)*(sin(pi*x) +
                 sin(pi*y) + (cos(pi*y)*sin(2*pi*t))/5 + 1))^2)/(16*ee*(sin(pi*x) +
                 sin(pi*y) + (cos(pi*y)*sin(2*pi*t))/5 + 1))) / N_A)&#x27;
  []
  #The manufactured eff. Efield solution
  [Ex_fun]
    type = ParsedFunction
    vars = &#x27;ee N_A diffpotential diffem muem massem diffmean_en diffion muion&#x27;
    vals = &#x27;ee N_A diffpotential diffem muem massem diffmean_en diffion muion&#x27;
    value = &#x27;pi*cos(pi*x)*(sin(pi*t) + 1)&#x27;
  []
  [Ey_fun]
    type = ParsedFunction
    vars = &#x27;ee N_A diffpotential diffem muem massem diffmean_en diffion muion&#x27;
    vals = &#x27;ee N_A diffpotential diffem muem massem diffmean_en diffion muion&#x27;
    value = &#x27;pi*cos(pi*y)*(sin(pi*t) + 1)&#x27;
  []
  #The manufactured potential solution
  [potential_fun]
    type = ParsedFunction
    vars = &#x27;ee N_A diffpotential diffem muem massem diffmean_en diffion muion&#x27;
    vals = &#x27;ee N_A diffpotential diffem muem massem diffmean_en diffion muion&#x27;
    value = &#x27;-(sin(pi*t) + 1.0)*(sin(pi*y) + sin(pi*x))&#x27;
  []

#Source Terms in moles
  #The electron source term.
  [em_source]
    type = ParsedFunction
    vars = &#x27;ee N_A diffpotential diffem muem massem diffmean_en diffion muion&#x27;
    vals = &#x27;ee N_A diffpotential diffem muem massem diffmean_en diffion muion&#x27;
    value = &#x27;(diffem*pi^2*sin(pi*x) + (diffem*pi^2*(5*sin(pi*y) +
              cos(pi*y)*sin(2*pi*t)))/5 + (2*pi*cos(2*pi*t)*cos(pi*y))/5 +
              (muem*pi^2*(sin(pi*t) + 1)*(5*sin(pi*x) + 5*sin(pi*y) +
              10*sin(pi*x)*sin(pi*y) - 10*cos(pi*x)^2 - 10*cos(pi*y)^2 +
              cos(pi*y)*sin(2*pi*t)*sin(pi*x) + 2*cos(pi*y)*sin(2*pi*t)*sin(pi*y) + 10))/5) / N_A&#x27;
  []
  #The ion source term.
  [ion_source]
    type = ParsedFunction
    vars = &#x27;ee N_A diffpotential diffem muem massem diffmean_en diffion muion&#x27;
    vals = &#x27;ee N_A diffpotential diffem muem massem diffmean_en diffion muion&#x27;
    value = &#x27;(diffion*pi^2*sin(pi*x) + (diffion*pi^2*(5*sin(pi*y) + cos(pi*y)*sin(2*pi*t)))/5 +
             (2*pi*cos(2*pi*t)*cos(pi*y))/5 - (muion*pi^2*(sin(pi*t) + 1)*(5*sin(pi*x) +
             5*sin(pi*y) + 10*sin(pi*x)*sin(pi*y) - 10*cos(pi*x)^2 -
             10*cos(pi*y)^2 + cos(pi*y)*sin(2*pi*t)*sin(pi*x) +
             2*cos(pi*y)*sin(2*pi*t)*sin(pi*y) + 10))/5) / N_A&#x27;
  []
  [energy_source]
    type = ParsedFunction
    vars = &#x27;ee N_A diffpotential diffem muem massem diffmean_en diffion muion&#x27;
    vals = &#x27;ee N_A diffpotential diffem muem massem diffmean_en diffion muion&#x27;
    value = &#x27;((3*massem*pi*(4*muem*pi^2*cos(pi*t)*(sin(pi*x) + sin(pi*y) +
              (cos(pi*y)*sin(2*pi*t))/5 + 1) + (8*muem*pi^2*cos(2*pi*t)*cos(pi*y)*(sin(pi*t) +
              1))/5)*(4*pi*diffem + 4*muem*pi*(sin(pi*t) + 1)*(sin(pi*x) + sin(pi*y) +
              (cos(pi*y)*sin(2*pi*t))/5 + 1)))/(8*ee*(sin(pi*x) + sin(pi*y) + (cos(pi*y)*sin(2*pi*t))/5 + 1)) -
              diffmean_en*((3*massem*pi^3*sin(pi*x)*(4*pi*diffem + 4*muem*pi*(sin(pi*t) + 1)*(sin(pi*x) +
              sin(pi*y) + (cos(pi*y)*sin(2*pi*t))/5 + 1))^2)/(16*ee*(sin(x*pi) + sin(y*pi) +
              (cos(y*pi)*sin(2*t*pi))/5 + 1)^2) + (3*massem*pi^3*cos(pi*x)^2*(4*pi*diffem +
              4*muem*pi*(sin(pi*t) + 1)*(sin(pi*x) + sin(pi*y) + (cos(pi*y)*sin(2*pi*t))/5 +
              1))^2)/(8*ee*(sin(x*pi) + sin(y*pi) + (cos(y*pi)*sin(2*t*pi))/5 + 1)^3) +
              (6*massem*muem^2*pi^5*cos(pi*x)^2*(sin(pi*t) + 1)^2)/(ee*(sin(pi*x) + sin(pi*y) +
              (cos(pi*y)*sin(2*pi*t))/5 + 1)) - (3*massem*muem*pi^4*sin(pi*x)*(4*pi*diffem +
              4*muem*pi*(sin(pi*t) + 1)*(sin(pi*x) + sin(pi*y) + (cos(pi*y)*sin(2*pi*t))/5 +
              1))*(sin(pi*t) + 1))/(2*ee*(sin(pi*x) + sin(pi*y) + (cos(pi*y)*sin(2*pi*t))/5 + 1)) -
              (3*massem*muem*pi^4*cos(pi*x)^2*(4*pi*diffem + 4*muem*pi*(sin(pi*t) + 1)*(sin(pi*x) +
              sin(pi*y) + (cos(pi*y)*sin(2*pi*t))/5 + 1))*(sin(pi*t) + 1))/(ee*(sin(x*pi) +
              sin(y*pi) + (cos(y*pi)*sin(2*t*pi))/5 + 1)^2)) - diffmean_en*((3*massem*pi*(pi*cos(pi*y) -
              (pi*sin(2*pi*t)*sin(pi*y))/5)^2*(4*pi*diffem + 4*muem*pi*(sin(pi*t) + 1)*(sin(pi*x) +
              sin(pi*y) + (cos(pi*y)*sin(2*pi*t))/5 + 1))^2)/(8*ee*(sin(x*pi) + sin(y*pi) +
              (cos(y*pi)*sin(2*t*pi))/5 + 1)^3) + (3*massem*pi*(pi^2*sin(pi*y) +
              (pi^2*cos(pi*y)*sin(2*pi*t))/5)*(4*pi*diffem + 4*muem*pi*(sin(pi*t) + 1)*(sin(pi*x) +
              sin(pi*y) + (cos(pi*y)*sin(2*pi*t))/5 + 1))^2)/(16*ee*(sin(x*pi) + sin(y*pi) +
              (cos(y*pi)*sin(2*t*pi))/5 + 1)^2) + (6*massem*muem^2*pi^3*(pi*cos(pi*y) -
              (pi*sin(2*pi*t)*sin(pi*y))/5)^2*(sin(pi*t) + 1)^2)/(ee*(sin(pi*x) + sin(pi*y) +
              (cos(pi*y)*sin(2*pi*t))/5 + 1)) - (3*massem*muem*pi^2*(pi*cos(pi*y) -
              (pi*sin(2*pi*t)*sin(pi*y))/5)^2*(4*pi*diffem + 4*muem*pi*(sin(pi*t) + 1)*(sin(pi*x) +
              sin(pi*y) + (cos(pi*y)*sin(2*pi*t))/5 + 1))*(sin(pi*t) + 1))/(ee*(sin(x*pi) +
              sin(y*pi) + (cos(y*pi)*sin(2*t*pi))/5 + 1)^2) - (3*massem*muem*pi^2*(pi^2*sin(pi*y) +
              (pi^2*cos(pi*y)*sin(2*pi*t))/5)*(4*pi*diffem + 4*muem*pi*(sin(pi*t) + 1)*(sin(pi*x) +
              sin(pi*y) + (cos(pi*y)*sin(2*pi*t))/5 + 1))*(sin(pi*t) + 1))/(2*ee*(sin(pi*x) +
              sin(pi*y) + (cos(pi*y)*sin(2*pi*t))/5 + 1))) -
              (3*massem*pi^2*cos(2*pi*t)*cos(pi*y)*(4*pi*diffem + 4*muem*pi*(sin(pi*t) + 1)*(sin(pi*x) +
              sin(pi*y) + (cos(pi*y)*sin(2*pi*t))/5 + 1))^2)/(40*ee*(sin(x*pi) + sin(y*pi) +
              (cos(y*pi)*sin(2*t*pi))/5 + 1)^2)) / N_A&#x27;
  []

  #The Ex source term.
  [Ex_source]
    type = ParsedFunction
    vars = &#x27;ee N_A diffpotential diffem muem massem diffmean_en diffion muion&#x27;
    vals = &#x27;ee N_A diffpotential diffem muem massem diffmean_en diffion muion&#x27;
    value = &#x27;pi^2*cos(pi*t)*cos(pi*x) + diffpotential*pi^3*cos(pi*x)*(sin(pi*t) + 1)&#x27;
  []
  [Ey_source]
    type = ParsedFunction
    vars = &#x27;ee N_A diffpotential diffem muem massem diffmean_en diffion muion&#x27;
    vals = &#x27;ee N_A diffpotential diffem muem massem diffmean_en diffion muion&#x27;
    value = &#x27;pi^2*cos(pi*t)*cos(pi*y) + diffpotential*pi^3*cos(pi*y)*(sin(pi*t) + 1)&#x27;
  []

  [potential_source]
    type = ParsedFunction
    vars = &#x27;ee N_A diffpotential diffem muem massem diffmean_en diffion muion&#x27;
    vals = &#x27;ee N_A diffpotential diffem muem massem diffmean_en diffion muion&#x27;
    value = &#x27;-pi*cos(pi*t)*(sin(pi*x) + sin(pi*y)) -
             diffpotential*pi^2*sin(pi*x)*(sin(pi*t) + 1) -
             diffpotential*pi^2*sin(pi*y)*(sin(pi*t) + 1)&#x27;
  []

  [em_ICs]
    type = ParsedFunction
    vars = &#x27;N_A&#x27;
    vals = &#x27;N_A&#x27;
    value = &#x27;log((3.0 + sin(pi/2*x)) / N_A)&#x27;
  []
  [ion_ICs]
    type = ParsedFunction
    vars = &#x27;N_A&#x27;
    vals = &#x27;N_A&#x27;
    value = &#x27;log((3.0 + sin(pi/2*x)) / N_A)&#x27;
  []
  [mean_en_ICs]
    type = ParsedFunction
    vars = &#x27;em_ICs&#x27;
    vals = &#x27;em_ICs&#x27;
    value = &#x27;log(32.) + em_ICs&#x27;
  []

  [em_left_Flux_BC]
    type = ParsedFunction
    vars = &#x27;ee N_A diffpotential diffem muem massem diffmean_en diffion muion&#x27;
    vals = &#x27;ee N_A diffpotential diffem muem massem diffmean_en diffion muion&#x27;
    value = &#x27;(-diffem*pi*cos(pi*x) - muem*pi*cos(pi*x)*(sin(pi*t) + 1)*(sin(pi*x) +
              sin(pi*y) + (cos(pi*y)*sin(2*pi*t))/5 + 1)) / N_A&#x27;
  []
  [em_down_Flux_BC]
    type = ParsedFunction
    vars = &#x27;ee N_A diffpotential diffem muem massem diffmean_en diffion muion&#x27;
    vals = &#x27;ee N_A diffpotential diffem muem massem diffmean_en diffion muion&#x27;
    value = &#x27;(-(diffem*pi*(5*cos(pi*y) - sin(2*pi*t)*sin(pi*y)))/5 -
              muem*pi*cos(pi*y)*(sin(pi*t) + 1)*(sin(pi*x) + sin(pi*y) +
              (cos(pi*y)*sin(2*pi*t))/5 + 1)) / N_A&#x27;
  []
[]

[BCs]
  #[em_left_BC]
  #  type = FunctionDirichletBC
  #  variable = em
  #  function = &#x27;em_fun&#x27;
  #  boundary = 3
  #  preset = true
  #[]
  #[em_left_BC]
  #  type = FunctionNeumannBC
  #  variable = em
  #  function = &#x27;em_left_Flux_BC&#x27;
  #  boundary = 3
  #  preset = true
  #[]
  [em_physical_diffusion_left]
    type = SakiyamaElectronDiffusionBC
    variable = em
    electron_energy = mean_en
    boundary = 3
    position_units = 1.0
  []
  [em_Ar+_second_emissions_left]
    type = SakiyamaSecondaryElectronWithEffEfieldBC
    variable = em
    Ex = Ex
    Ey = Ey
    ions = ion
    emission_coeffs = &#x27;users_gamma&#x27;
    boundary = 3
    position_units = 1.0
  []

  [em_right_BC]
    type = FunctionDirichletBC
    variable = em
    function = &#x27;em_fun&#x27;
    boundary = 1
    preset = true
  []

  #[em_down_BC]
  #  type = FunctionDirichletBC
  #  variable = em
  #  function = &#x27;em_fun&#x27;
  #  boundary = 0
  #  preset = true
  #[]
  #[em_down_BC]
  #  type = FunctionNeumannBC
  #  variable = em
  #  function = &#x27;em_down_Flux_BC&#x27;
  #  boundary = 0
  #  preset = true
  #[]
  [em_physical_diffusion_down]
    type = SakiyamaElectronDiffusionBC
    variable = em
    electron_energy = mean_en
    boundary = 0
    position_units = 1.0
  []
  [em_Ar+_second_emissions_down]
    type = SakiyamaSecondaryElectronWithEffEfieldBC
    variable = em
    Ex = Ex
    Ey = Ey
    ions = ion
    emission_coeffs = &#x27;users_gamma&#x27;
    boundary = 0
    position_units = 1.0
  []

  [em_up_BC]
    type = FunctionDirichletBC
    variable = em
    function = &#x27;em_fun&#x27;
    boundary = 2
    preset = true
  []

  [ion_BC]
    type = FunctionDirichletBC
    variable = ion
    function = &#x27;ion_fun&#x27;
    boundary = &#x27;0 1 2 3&#x27;
    preset = true
  []

  [energy_BC]
    type = FunctionDirichletBC
    variable = mean_en
    function = &#x27;mean_en_fun&#x27;
    boundary = &#x27;0 1 2 3&#x27;
    preset = true
  []

  [Ex_BC]
    type = FunctionDirichletBC
    variable = Ex
    function = &#x27;Ex_fun&#x27;
    boundary = &#x27;0 1 2 3&#x27;
    preset = true
  []

  [Ey_BC]
    type = FunctionDirichletBC
    variable = Ey
    function = &#x27;Ey_fun&#x27;
    boundary = &#x27;0 1 2 3&#x27;
    preset = true
  []

  [potential_BC]
    type = FunctionDirichletBC
    variable = potential
    function = &#x27;potential_fun&#x27;
    boundary = &#x27;0 1 2 3&#x27;
    preset = true
  []
[]

[Materials]
  [field_solver]
    type = FieldSolverMaterial
    potential = potential
  []
  [Material_Coeff]
    type = GenericFunctionMaterial
    prop_names =  &#x27;e  N_A  massem diffpotential  diffEx         diffEy&#x27;
    prop_values = &#x27;ee N_A  massem diffpotential  diffpotential  diffpotential &#x27;
  []
  [ADMaterial_Coeff_Set1]
    type = ADGenericFunctionMaterial
    prop_names =  &#x27;diffion  muion  diffem  muem  diffmean_en&#x27;
    prop_values = &#x27;diffion  muion  diffem  muem  diffmean_en&#x27;
  []
  [Charge_Signs]
    type = GenericConstantMaterial
    prop_names =  &#x27;sgnem  sgnion  sgnmean_en&#x27;
    prop_values = &#x27;-1.0   1.0     -1.0&#x27;
  []
  [emission_coeffs]
    type = ADGenericConstantMaterial
    prop_names = &#x27;users_gamma&#x27;
    prop_values = &#x27;1.0&#x27;
  []
[]

[Postprocessors]
  [em_l2Error]
    type = ElementL2Error
    variable = em
    function = em_fun
  []
  [ion_l2Error]
    type = ElementL2Error
    variable = ion
    function = ion_fun
  []
  [mean_en_l2Error]
    type = ElementL2Error
    variable = mean_en
    function = mean_en_fun
  []

  [Ex_l2Error]
    type = ElementL2Error
    variable = Ex
    function = Ex_fun
  []
  [Ey_l2Error]
    type = ElementL2Error
    variable = Ey
    function = Ey_fun
  []

  [potential_l2Error]
    type = ElementL2Error
    variable = potential
    function = potential_fun
  []

  [h]
    type = AverageElementSize
  []
[]

[Preconditioning]
  active = &#x27;smp&#x27;
  [smp]
    type = SMP
    full = true
  []

  [fdp]
    type = FDP
    full = true
  []
[]

[Executioner]
  type = Transient
  start_time = 50
  end_time = 51

  # dt = 0.008
  dt = 0.02

  automatic_scaling = true
  compute_scaling_once = false
  petsc_options = &#x27;-snes_converged_reason -snes_linesearch_monitor&#x27;
  solve_type = NEWTON
  line_search = none
  petsc_options_iname = &#x27;-pc_type -pc_factor_shift_type -pc_factor_shift_amount&#x27;
  petsc_options_value = &#x27;lu NONZERO 1.e-10&#x27;

  scheme = bdf2

  nl_abs_tol = 1e-13
[]

[Outputs]
  perf_graph = true
  [out]
    type = Exodus
    interval = 10
  []
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="4dcfa089-3e58-4186-aa53-25393a51d3ee"><div class="modal-content"><h4>(tutorial/tutorial04-PressureVsTe/RF_Plasma_WithOut_Metastables-1Torr.i)</h4><pre style="max-height:350px;"><code class="language-moose">#This tutorial is of an argon CCP discharge running at
#different pressures. In this case, the electron and ion coefficient are
#linearly proportional. For the following pressures,
#(0.1, 1, 10, 100, 1000 Torr)
#change the following lines (144, 245, and 257-258).

#A uniform scaling factor of the mesh.
#E.g if set to 1.0, there is not scaling
# and if set to 0.010, there mesh is scaled by a cm
dom0Scale = 1.0

[GlobalParams]
  #Scales the potential by V or kV
  potential_units = kV
  #Converts density from #/m^3 to moles/m^3
  use_moles = true
[]

[Mesh]
  #Mesh is defined by a previous output file
  [geo]
    type = FileMeshGenerator
    file = &#x27;RF_Plasma_WithOut_Metastables_IC.e&#x27;
    use_for_exodus_restart = true
  []
  #Renames all sides with the specified normal
  #For 1D, this is used to rename the end points of the mesh
  [left]
    type = SideSetsFromNormalsGenerator
    normals = &#x27;-1 0 0&#x27;
    new_boundary = &#x27;left&#x27;
    input = geo
  []
  [right]
    type = SideSetsFromNormalsGenerator
    normals = &#x27;1 0 0&#x27;
    new_boundary = &#x27;right&#x27;
    input = left
  []
[]

#Defines the problem type, such as FE, eigen value problem, etc.
[Problem]
  type = FEProblem
[]

#Defining IC from previous output file
# (The ICs block is not used in this case)
[Variables]
  [em]
    initial_from_file_var = em
  []
  [potential]
    initial_from_file_var = potential
  []
  [Ar+]
    initial_from_file_var = Ar+
  []
  [mean_en]
    initial_from_file_var = mean_en
  []
[]

[DriftDiffusionAction]
  [Plasma]
    #User define name for electrons (usually &#x27;em&#x27;)
    electrons = em
    #User define name for ions
    charged_particle = Ar+
    #User define name for potential (usually &#x27;potential&#x27;)
    field = potential
    #Defines if this potential exist in only one block/material (set &#x27;true&#x27; for single gases)
    Is_field_unique = true
    #User define name for the electron mean energy density (usually &#x27;mean_en&#x27;)
    mean_energy = mean_en
    #The position scaling for the mesh, define at top of input file
    position_units = ${dom0Scale}
    #Additional outputs, such as ElectronTemperature, Current, and EField.
    Additional_Outputs = &#x27;ElectronTemperature Current EField&#x27;
  []
[]

[Reactions]
  [Argon]
    #Name of reactant species that are variables
    species = &#x27;em Ar+&#x27;
    #Name of reactant species that are auxvariables
    aux_species = &#x27;Ar&#x27;
    #Type of coefficient (rate or townsend)
    reaction_coefficient_format = &#x27;rate&#x27;
    #Name of background gas
    gas_species = &#x27;Ar&#x27;
    #Name of the electron mean energy density (usually &#x27;mean_en&#x27;)
    electron_energy = &#x27;mean_en&#x27;
    #Name of the electrons (usually &#x27;em&#x27;)
    electron_density = &#x27;em&#x27;
    #Defines if electrons are tracked
    include_electrons = true
    #Defines directory holding rate text files
    file_location = &#x27;rate_coefficients&#x27;
    #Name of name for potential (usually &#x27;potential&#x27;)
    potential = &#x27;potential&#x27;
    #Defines if log form is used (true for Zapdos)
    use_log = true
    #Defines if automatic differentiation is used (true for Zapdos)
    use_ad = true
    #The position scaling for the mesh, define at top of input file
    position_units = ${dom0Scale}
    #Name of material block (&#x27;0&#x27; for an user undefined block)
    block = 0
    #Inputs of the plasma chemsity
    #e.g. Reaction : Constant or EEDF dependent [Threshold Energy] (Text file name)
    #     em + Ar -&gt; em + Ar*        : EEDF [-11.56] (reaction1)
    reactions = &#x27;em + Ar -&gt; em + Ar*        : EEDF [-11.56] (reaction1)
                 em + Ar -&gt; em + em + Ar+   : EEDF [-15.7] (reaction2)&#x27;
  []
[]

[AuxVariables]
  #Add a scaled position units used for plotting other element AuxVariables
  [x]
    order = CONSTANT
    family = MONOMIAL
  []

  #Background gas (e.g Ar)
  [Ar]
  []
[]

[AuxKernels]
  #Add at scaled position units used for plotting other element AuxVariables
  [x_ng]
    type = Position
    variable = x
    position_units = ${dom0Scale}
  []

  #Background gas number density (e.g. for 1Torr)
  [Ar_val]
    type = FunctionAux
    variable = Ar
    function = &#x27;log(3.22e22/6.022e23)&#x27;
    execute_on = INITIAL
  []
[]

#Define function used throughout the input file (e.g. BCs)
[Functions]
  [potential_bc_func]
    type = ParsedFunction
    expression = &#x27;0.100*sin(2*3.1415926*13.56e6*t)&#x27;
  []
[]

#Currently there is no Action for BC (but one is currently in development)
#Below is the Sakiyama family of BC
#(For other BC example, please look at Tutorial 05 and Tutorial 06)
[BCs]
  #Voltage Boundary Condition
  [potential_left]
    type = FunctionDirichletBC
    variable = potential
    boundary = &#x27;left&#x27;
    function = potential_bc_func
    preset = false
  []
  [potential_dirichlet_right]
    type = DirichletBC
    variable = potential
    boundary = &#x27;right&#x27;
    value = 0
    preset = false
  []

  #Boundary conditions for electons
  [em_physical_diffusion]
    type = SakiyamaElectronDiffusionBC
    variable = em
    electron_energy = mean_en
    boundary = &#x27;left right&#x27;
    position_units = ${dom0Scale}
  []
  [em_Ar+_second_emissions]
    type = SakiyamaSecondaryElectronBC
    variable = em
    ions = Ar+
    emission_coeffs = 0.01
    boundary = &#x27;left right&#x27;
    position_units = ${dom0Scale}
  []

  #Boundary conditions for ions
  [Ar+_physical_advection]
    type = SakiyamaIonAdvectionBC
    variable = Ar+
    boundary = &#x27;left right&#x27;
    position_units = ${dom0Scale}
  []

  #New Boundary conditions for mean energy, should be the same as in paper
  [mean_en_physical_diffusion]
    type = SakiyamaEnergyDiffusionBC
    variable = mean_en
    electrons = em
    boundary = &#x27;left right&#x27;
    position_units = ${dom0Scale}
  []
  [mean_en_Ar+_second_emissions]
    type = SakiyamaEnergySecondaryElectronBC
    variable = mean_en
    electrons = em
    ions = Ar+
    Tse_equal_Te = false
    secondary_electron_energy = 1
    emission_coeffs = 0.01
    boundary = &#x27;left right&#x27;
    position_units = ${dom0Scale}
  []
[]

[Materials]
  #The material properties for electrons.
  #Also hold universal constant, such as Avogadro&#x27;s number, elementary charge, etc.
  [GasBasics]
    type = GasElectronMoments
    #True means variable electron coeff, defined by user
    interp_trans_coeffs = true
    #Leave as false (CRANE accounts of elastic coeff.)
    interp_elastic_coeff = false
    #Leave as false, unless computational error is due to rapid coeff. changes
    ramp_trans_coeffs = false
    #Name for electrons (usually &#x27;em&#x27;)
    em = em
    #Name for the electron mean energy density (usually &#x27;mean_en&#x27;)
    mean_en = mean_en
    #User difine pressure in pa
    user_p_gas = 133.322
    #True if pressure dependent coeff.
    pressure_dependent_electron_coeff = true
    #Name of text file with electron properties
    property_tables_file = rate_coefficients/electron_moments.txt
  []
  #The material properties of the ion
  [gas_species_0]
    type = ADHeavySpecies
    heavy_species_name = Ar+
    heavy_species_mass = 6.64e-26
    heavy_species_charge = 1.0
    mobility = 0.144409938
    diffusivity = 6.428571e-3
  []
  [gas_species_2]
  #The material properties of the background gas
    type = ADHeavySpecies
    heavy_species_name = Ar
    heavy_species_mass = 6.64e-26
    heavy_species_charge = 0.0
  []
[]

[Postprocessors]
  [ElectronTemp_Average]
    type = ElementAverageValue
    variable = e_temp
  []
[]

#Preconditioning options
#Learn more at: https://mooseframework.inl.gov/syntax/Preconditioning/index.html
[Preconditioning]
  active = &#x27;smp&#x27;
  [smp]
    type = SMP
    full = true
  []

  [fdp]
    type = FDP
    full = true
  []
[]

#How to execute the problem.
#Defines type of solve (such as steady or transient),
# solve type (Newton, PJFNK, etc.) and tolerances
[Executioner]
  type = Transient
  start_time = 7.3746e-5
  end_time = 9.3746e-5
  dt = 1e-9
  dtmin = 1e-14
  scheme = bdf2
  solve_type = NEWTON

  petsc_options = &#x27;-snes_converged_reason -snes_linesearch_monitor&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_factor_shift_type -pc_factor_shift_amount -snes_linesearch_minlambda&#x27;
  petsc_options_value = &#x27;lu NONZERO 1.e-10 1e-3&#x27;

  nl_rel_tol = 1e-08
  l_max_its = 20
[]

#Defines the output type of the file (multiple output files can be define per run)
[Outputs]
  perf_graph = true
  [out]
    type = Exodus
  []
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="d8ab1934-742c-4c96-8a7a-952c15e7277e"><div class="modal-content"><h4>(test/tests/Conference_Syntax_Tests/Lymberopoulos_with_argon_metastables_2D_At1Torr.i)</h4><pre style="max-height:350px;"><code class="language-moose">dom0Scale = 25.4e-3
#dom0Scale=1.0

[GlobalParams]
  potential_units = V
  use_moles = true
[]

[Mesh]
  type = FileMesh
  file = &#x27;GEC_mesh.msh&#x27;
  coord_type = RZ
  rz_coord_axis = Y
[]

[Variables]
  [em]
  []

  [Ar+]
  []

  [Ar*]
  []

  [mean_en]
  []

  [potential]
  []

  [potential_ion]
  []
[]

[Kernels]
  #Electron Equations (Same as in paper)
  #Time Derivative term of electron
  [em_time_deriv]
    type = ElectronTimeDerivative
    variable = em
  []
  #Advection term of electron
  [em_advection]
    type = EFieldAdvection
    variable = em
    position_units = ${dom0Scale}
  []
  #Diffusion term of electrons
  [em_diffusion]
    type = CoeffDiffusion
    variable = em
    position_units = ${dom0Scale}
  []
  #Net electron production from ionization
  [em_ionization]
    type = EEDFReactionLog
    variable = em
    electrons = em
    target = Ar
    mean_energy = mean_en
    reaction = &#x27;em + Ar -&gt; em + em + Ar+&#x27;
    coefficient = 1
  []
  #Net electron production from step-wise ionization
  [em_stepwise_ionization]
    type = EEDFReactionLog
    variable = em
    electrons = em
    target = Ar*
    mean_energy = mean_en
    reaction = &#x27;em + Ar* -&gt; em + em + Ar+&#x27;
    coefficient = 1
  []
  #Net electron production from metastable pooling
  [em_pooling]
    type = ReactionSecondOrderLog
    variable = em
    v = Ar*
    w = Ar*
    reaction = &#x27;Ar* + Ar* -&gt; Ar+ + Ar + em&#x27;
    coefficient = 1
  []

  #Argon Ion Equations (Same as in paper)
  #Time Derivative term of the ions
  [Ar+_time_deriv]
    type = ElectronTimeDerivative
    variable = Ar+
  []
  #Advection term of ions
  [Ar+_advection]
    type = EFieldAdvection
    variable = Ar+
    position_units = ${dom0Scale}
  []
  [Ar+_diffusion]
    type = CoeffDiffusion
    variable = Ar+
    position_units = ${dom0Scale}
  []
  #Net ion production from ionization
  [Ar+_ionization]
    type = EEDFReactionLog
    variable = Ar+
    electrons = em
    target = Ar
    mean_energy = mean_en
    reaction = &#x27;em + Ar -&gt; em + em + Ar+&#x27;
    coefficient = 1
  []
  #Net ion production from step-wise ionization
  [Ar+_stepwise_ionization]
    type = EEDFReactionLog
    variable = Ar+
    electrons = em
    target = Ar*
    mean_energy = mean_en
    reaction = &#x27;em + Ar* -&gt; em + em + Ar+&#x27;
    coefficient = 1
  []
  #Net ion production from metastable pooling
  [Ar+_pooling]
    type = ReactionSecondOrderLog
    variable = Ar+
    v = Ar*
    w = Ar*
    reaction = &#x27;Ar* + Ar* -&gt; Ar+ + Ar + em&#x27;
    coefficient = 1
  []

  #Argon Excited Equations (Same as in paper)
  #Time Derivative term of excited Argon
  [Ar*_time_deriv]
    type = ElectronTimeDerivative
    variable = Ar*
  []
  #Diffusion term of excited Argon
  [Ar*_diffusion]
    type = CoeffDiffusion
    variable = Ar*
    position_units = ${dom0Scale}
  []
  #Net excited Argon production from excitation
  [Ar*_excitation]
    type = EEDFReactionLog
    variable = Ar*
    electrons = em
    target = Ar
    mean_energy = mean_en
    reaction = &#x27;em + Ar -&gt; em + Ar*&#x27;
    coefficient = 1
  []
  #Net excited Argon loss from step-wise ionization
  [Ar*_stepwise_ionization]
    type = EEDFReactionLog
    variable = Ar*
    electrons = em
    target = Ar*
    mean_energy = mean_en
    reaction = &#x27;em + Ar* -&gt; em + em + Ar+&#x27;
    coefficient = -1
  []
  #Net excited Argon loss from superelastic collisions
  [Ar*_collisions]
    type = EEDFReactionLog
    variable = Ar*
    electrons = em
    target = Ar*
    mean_energy = mean_en
    reaction = &#x27;em + Ar* -&gt; em + Ar&#x27;
    coefficient = -1
  []
  #Net excited Argon loss from quenching to resonant
  [Ar*_quenching]
    type = EEDFReactionLog
    variable = Ar*
    electrons = em
    target = Ar*
    mean_energy = mean_en
    reaction = &#x27;em + Ar* -&gt; em + Ar_r&#x27;
    coefficient = -1
  []
  #Net excited Argon loss from  metastable pooling
  [Ar*_pooling]
    type = ReactionSecondOrderLog
    variable = Ar*
    v = Ar*
    w = Ar*
    reaction = &#x27;Ar* + Ar* -&gt; Ar+ + Ar + em&#x27;
    coefficient = -2
    _v_eq_u = true
    _w_eq_u = true
  []
  #Net excited Argon loss from two-body quenching
  [Ar*_2B_quenching]
    type = ReactionSecondOrderLog
    variable = Ar*
    v = Ar*
    w = Ar
    reaction = &#x27;Ar* + Ar -&gt; Ar + Ar&#x27;
    coefficient = -1
    _v_eq_u = true
  []
  #Net excited Argon loss from three-body quenching
  [Ar*_3B_quenching]
    type = ReactionThirdOrderLog
    variable = Ar*
    v = Ar*
    w = Ar
    x = Ar
    reaction = &#x27;Ar* + Ar + Ar -&gt; Ar_2 + Ar&#x27;
    coefficient = -1
    _v_eq_u = true
  []

  #Voltage Equations (Same as in paper)
  #Voltage term in Poissons Eqaution
  [potential_diffusion_dom0]
    type = CoeffDiffusionLin
    variable = potential
    position_units = ${dom0Scale}
  []
  #Ion term in Poissons Equation
  [Ar+_charge_source]
    type = ChargeSourceMoles_KV
    variable = potential
    charged = Ar+
  []
  #Electron term in Poissons Equation
  [em_charge_source]
    type = ChargeSourceMoles_KV
    variable = potential
    charged = em
  []

  #Since the paper uses electron temperature as a variable, the energy equation is in
  #a different form but should be the same physics
  #Time Derivative term of electron energy
  [mean_en_time_deriv]
    type = ElectronTimeDerivative
    variable = mean_en
  []
  #Advection term of electron energy
  [mean_en_advection]
    type = EFieldAdvection
    variable = mean_en
    position_units = ${dom0Scale}
  []
  #Diffusion term of electrons energy
  [mean_en_diffusion]
    type = CoeffDiffusion
    variable = mean_en
    position_units = ${dom0Scale}
  []
  #Joule Heating term
  [mean_en_joule_heating]
    type = JouleHeating
    variable = mean_en
    em = em
    position_units = ${dom0Scale}
  []
  #Energy loss from ionization
  [Ionization_Loss]
    type = EEDFEnergyLog
    variable = mean_en
    electrons = em
    target = Ar
    reaction = &#x27;em + Ar -&gt; em + em + Ar+&#x27;
    threshold_energy = -15.7
  []
  #Energy loss from excitation
  [Excitation_Loss]
    type = EEDFEnergyLog
    variable = mean_en
    electrons = em
    target = Ar
    reaction = &#x27;em + Ar -&gt; em + Ar*&#x27;
    threshold_energy = -11.56
  []
  #Energy loss from step-wise ionization
  [Stepwise_Ionization_Loss]
    type = EEDFEnergyLog
    variable = mean_en
    electrons = em
    target = Ar*
    reaction = &#x27;em + Ar* -&gt; em + em + Ar+&#x27;
    threshold_energy = -4.14
  []
  #Energy gain from superelastic collisions
  [Collisions_Loss]
    type = EEDFEnergyLog
    variable = mean_en
    electrons = em
    target = Ar*
    reaction = &#x27;em + Ar* -&gt; em + Ar&#x27;
    threshold_energy = 11.56
  []
  # Energy loss from elastic collisions
  [Elastic_loss]
    type = EEDFElasticLog
    variable = mean_en
    electrons = em
    target = Ar
    reaction = &#x27;em + Ar -&gt; em + Ar&#x27;
  []

  #Effective potential for the Ions
  [Ion_potential_time_deriv]
    type = TimeDerivative
    variable = potential_ion
  []
  [Ion_potential_reaction]
    type = ScaledReaction
    variable = potential_ion
    collision_freq = 1283370.875
  []
  [Ion_potential_coupled_force]
    type = CoupledForce
    variable = potential_ion
    v = potential
    coef = 1283370.875
  []
[]

[AuxVariables]
  [emDeBug]
  []
  [Ar+_DeBug]
  []
  [Ar*_DeBug]
  []
  [mean_enDeBug]
  []
  [potential_DeBug]
  []

  [Te]
    order = CONSTANT
    family = MONOMIAL
  []

  [x]
    order = CONSTANT
    family = MONOMIAL
  []
  [x_node]
  []

  [y]
    order = CONSTANT
    family = MONOMIAL
  []
  [y_node]
  []

  [rho]
    order = CONSTANT
    family = MONOMIAL
  []

  [em_lin]
    order = CONSTANT
    family = MONOMIAL
  []

  [Ar+_lin]
    order = CONSTANT
    family = MONOMIAL
  []

  [Ar*_lin]
    order = CONSTANT
    family = MONOMIAL
  []

  [Ar]
  []

  [Efieldx]
    order = CONSTANT
    family = MONOMIAL
  []
  [Efieldy]
    order = CONSTANT
    family = MONOMIAL
  []

  [Current_em]
    order = CONSTANT
    family = MONOMIAL
    block = &#x27;plasma&#x27;
  []
  [Current_Ar]
    order = CONSTANT
    family = MONOMIAL
    block = &#x27;plasma&#x27;
  []
  [emRate]
    order = CONSTANT
    family = MONOMIAL
    block = &#x27;plasma&#x27;
  []
  [exRate]
    order = CONSTANT
    family = MONOMIAL
    block = &#x27;plasma&#x27;
  []
  [swRate]
    order = CONSTANT
    family = MONOMIAL
    block = &#x27;plasma&#x27;
  []
  [deexRate]
    order = CONSTANT
    family = MONOMIAL
    block = &#x27;plasma&#x27;
  []
  [quRate]
    order = CONSTANT
    family = MONOMIAL
    block = &#x27;plasma&#x27;
  []
  [poolRate]
    order = CONSTANT
    family = MONOMIAL
    block = &#x27;plasma&#x27;
  []
  [TwoBRate]
    order = CONSTANT
    family = MONOMIAL
    block = &#x27;plasma&#x27;
  []
  [ThreeBRate]
    order = CONSTANT
    family = MONOMIAL
    block = &#x27;plasma&#x27;
  []

[]

[AuxKernels]
  #[emDeBug]
  #  type = DebugResidualAux
  #  variable = emDeBug
  #  debug_variable = em
  #[]
  #[Ar+_DeBug]
  #  type = DebugResidualAux
  #  variable = Ar+_DeBug
  #  debug_variable = Ar+
  #[]
  #[mean_enDeBug]
  #  type = DebugResidualAux
  #  variable = mean_enDeBug
  #  debug_variable = mean_en
  #[]
  #[Ar*_DeBug]
  #  type = DebugResidualAux
  #  variable = Ar*_DeBug
  #  debug_variable = Ar*
  #[]
  #[Potential_DeBug]
  #  type = DebugResidualAux
  #  variable = potential_DeBug
  #  debug_variable = potential
  #[]

  [emRate]
    type = ProcRateForRateCoeff
    variable = emRate
    v = em
    w = Ar
    reaction = &#x27;em + Ar -&gt; em + em + Ar+&#x27;
  []
  [exRate]
    type = ProcRateForRateCoeff
    variable = exRate
    v = em
    w = Ar*
    reaction = &#x27;em + Ar -&gt; em + Ar*&#x27;
  []
  [swRate]
    type = ProcRateForRateCoeff
    variable = swRate
    v = em
    w = Ar*
    reaction = &#x27;em + Ar* -&gt; em + em + Ar+&#x27;
  []
  [deexRate]
    type = ProcRateForRateCoeff
    variable = deexRate
    v = em
    w = Ar*
    reaction = &#x27;em + Ar* -&gt; em + Ar&#x27;
  []
  [quRate]
    type = ProcRateForRateCoeff
    variable = quRate
    v = em
    w = Ar*
    reaction = &#x27;em + Ar* -&gt; em + Ar_r&#x27;
  []
  [poolRate]
    type = ProcRateForRateCoeff
    variable = poolRate
    v = Ar*
    w = Ar*
    reaction = &#x27;Ar* + Ar* -&gt; Ar+ + Ar + em&#x27;
  []
  [TwoBRate]
    type = ProcRateForRateCoeff
    variable = TwoBRate
    v = Ar*
    w = Ar
    reaction = &#x27;Ar* + Ar -&gt; Ar + Ar&#x27;
  []
  [ThreeBRate]
    type = ProcRateForRateCoeffThreeBody
    variable = ThreeBRate
    v = Ar*
    w = Ar
    x = Ar
    reaction = &#x27;Ar* + Ar + Ar -&gt; Ar_2 + Ar&#x27;
  []
  [Te]
    type = ElectronTemperature
    variable = Te
    electron_density = em
    mean_en = mean_en
  []
  [x_g]
    type = Position
    variable = x
    position_units = ${dom0Scale}
  []
  [x_ng]
    type = Position
    variable = x_node
    position_units = ${dom0Scale}
  []

  [y_g]
    type = Position
    variable = y
    position_units = ${dom0Scale}
  []
  [y_ng]
    type = Position
    variable = y_node
    position_units = ${dom0Scale}
  []

  [em_lin]
    type = DensityMoles
    variable = em_lin
    density_log = em
  []
  [Ar+_lin]
    type = DensityMoles
    variable = Ar+_lin
    density_log = Ar+
  []
  [Ar*_lin]
    type = DensityMoles
    variable = Ar*_lin
    density_log = Ar*
  []

  [Ar_val]
    type = ConstantAux
    variable = Ar
    # value = 3.22e22
    value = -2.928623
    execute_on = INITIAL
  []

  [Efieldx_calc]
    type = Efield
    component = 0
    variable = Efieldx
    position_units = ${dom0Scale}
  []
  [Efieldy_calc]
    type = Efield
    component = 1
    variable = Efieldy
    position_units = ${dom0Scale}
  []

  [Current_em]
    type = ADCurrent
    density_log = em
    variable = Current_em
    art_diff = false
    block = &#x27;plasma&#x27;
    position_units = ${dom0Scale}
  []
  [Current_Ar]
    type = ADCurrent
    density_log = Ar+
    variable = Current_Ar
    art_diff = false
    block = &#x27;plasma&#x27;
    position_units = ${dom0Scale}
  []

[]

[BCs]
  #Voltage Boundary Condition, same as in paper
  [potential_top_plate]
    type = FunctionDirichletBC
    variable = potential
    boundary = &#x27;Top_Electrode&#x27;
    function = potential_top_bc_func
  []
  [potential_bottom_plate]
    type = FunctionDirichletBC
    variable = potential
    boundary = &#x27;Bottom_Electrode&#x27;
    function = potential_bottom_bc_func
  []
  [potential_dirichlet_bottom_plate]
    type = DirichletBC
    variable = potential
    boundary = &#x27;Walls&#x27;
    value = 0
  []
  [potential_Dielectric]
    type = EconomouDielectricBC
    variable = potential
    boundary = &#x27;Top_Insulator Bottom_Insulator&#x27;
    electrons = em
    ions = Ar+
    ion_potentials = potential_ion
    electron_energy = mean_en
    dielectric_constant = 1.859382e-11
    thickness = 0.0127
    emission_coeffs = 0.01
    position_units = ${dom0Scale}
  []

  #New Boundary conditions for electons, same as in paper
  [em_physical_diffusion]
    type = SakiyamaElectronDiffusionBC
    variable = em
    electron_energy = mean_en
    boundary = &#x27;Top_Electrode Bottom_Electrode Top_Insulator Bottom_Insulator Walls&#x27;
    position_units = ${dom0Scale}
  []
  [em_Ar+_second_emissions]
    type = SakiyamaSecondaryElectronBC
    variable = em
    ions = Ar+
    emission_coeffs = 0.01
    boundary = &#x27;Top_Electrode Bottom_Electrode Top_Insulator Bottom_Insulator Walls&#x27;
    position_units = ${dom0Scale}
  []

  #New Boundary conditions for ions, should be the same as in paper
  [Ar+_physical_advection]
    type = SakiyamaIonAdvectionBC
    variable = Ar+
    boundary = &#x27;Top_Electrode Bottom_Electrode Top_Insulator Bottom_Insulator Walls&#x27;
    position_units = ${dom0Scale}
  []

  #New Boundary conditions for ions, should be the same as in paper
  #(except the metastables are not set to zero, since Zapdos uses log form)
  [Ar*_physical_diffusion]
    type = LogDensityDirichletBC
    variable = Ar*
    boundary = &#x27;Top_Electrode Bottom_Electrode Top_Insulator Bottom_Insulator Walls&#x27;
    value = 100
  []

  #New Boundary conditions for mean energy, should be the same as in paper
  [mean_en_physical_diffusion]
    type = SakiyamaEnergyDiffusionBC
    variable = mean_en
    electrons = em
    boundary = &#x27;Top_Electrode Bottom_Electrode Top_Insulator Bottom_Insulator Walls&#x27;
    position_units = ${dom0Scale}
  []
  [mean_en_Ar+_second_emissions]
    type = SakiyamaEnergySecondaryElectronBC
    variable = mean_en
    electrons = em
    ions = Ar+
    Tse_equal_Te = true
    emission_coeffs = 0.01
    boundary = &#x27;Top_Electrode Bottom_Electrode Top_Insulator Bottom_Insulator Walls&#x27;
    position_units = ${dom0Scale}
  []

[]

[ICs]
  [em_ic]
    type = FunctionIC
    variable = em
    function = density_ic_func
  []
  [Ar+_ic]
    type = FunctionIC
    variable = Ar+
    function = density_ic_func
  []
  [Ar*_ic]
    type = FunctionIC
    variable = Ar*
    function = meta_density_ic_func
  []
  [mean_en_ic]
    type = FunctionIC
    variable = mean_en
    function = energy_density_ic_func
  []

  [potential_ic]
    type = FunctionIC
    variable = potential
    function = potential_ic_func
  []
[]

[Functions]
  [potential_top_bc_func]
    type = ParsedFunction
    expression = &#x27;30*sin(2*3.1415926*13.56e6*t)&#x27;
  []
  [potential_bottom_bc_func]
    type = ParsedFunction
    expression = &#x27;-30*sin(2*3.1415926*13.56e6*t)&#x27;
  []
  [potential_ic_func]
    type = ParsedFunction
    expression = 0
  []
  [density_ic_func]
    type = ParsedFunction
    expression = &#x27;log((1e14)/6.022e23)&#x27;
  []
  [meta_density_ic_func]
    type = ParsedFunction
    expression = &#x27;log((1e16)/6.022e23)&#x27;
  []
  [energy_density_ic_func]
    type = ParsedFunction
    expression = &#x27;log((3./2.)) + log((1e14)/6.022e23)&#x27;
  []
[]

[Materials]
  [field_solver]
    type = FieldSolverMaterial
    potential = potential
  []
  [GasBasics]
    type = GasElectronMoments
    interp_trans_coeffs = true
    interp_elastic_coeff = false
    ramp_trans_coeffs = false
    user_p_gas = 133.322
    em = em
    mean_en = mean_en
    user_se_coeff = 0.00
    property_tables_file = Argon_reactions_paper_RateCoefficients/electron_moments.txt
  []
  [gas_species_0]
    type = ADHeavySpecies
    heavy_species_name = Ar+
    heavy_species_mass = 6.64e-26
    heavy_species_charge = 1.0
    mobility = 1.44409938
    diffusivity = 6.428571e-2
  []
  [gas_species_1]
    type = ADHeavySpecies
    heavy_species_name = Ar*
    heavy_species_mass = 6.64e-26
    heavy_species_charge = 0.0
    diffusivity = 7.515528e-2
  []
  [gas_species_2]
    type = ADHeavySpecies
    heavy_species_name = Ar
    heavy_species_mass = 6.64e-26
    heavy_species_charge = 0.0
  []
  [reaction_00]
    type = ZapdosEEDFRateConstant
    mean_energy = mean_en
    property_file = &#x27;Argon_reactions_paper_RateCoefficients/ar_elastic.txt&#x27;
    reaction = &#x27;em + Ar -&gt; em + Ar&#x27;
    electrons = em
  []
  [reaction_0]
    type = ZapdosEEDFRateConstant
    property_file = &#x27;Argon_reactions_paper_RateCoefficients/ar_excitation.txt&#x27;
    reaction = &#x27;em + Ar -&gt; em + Ar*&#x27;
    mean_energy = mean_en
    electrons = em
  []
  [reaction_1]
    type = ZapdosEEDFRateConstant
    property_file = &#x27;Argon_reactions_paper_RateCoefficients/ar_ionization.txt&#x27;
    reaction = &#x27;em + Ar -&gt; em + em + Ar+&#x27;
    mean_energy = mean_en
    electrons = em
  []
  [reaction_2]
    type = ZapdosEEDFRateConstant
    property_file = &#x27;Argon_reactions_paper_RateCoefficients/ar_deexcitation.txt&#x27;
    reaction = &#x27;em + Ar* -&gt; em + Ar&#x27;
    mean_energy = mean_en
    electrons = em
  []
  [reaction_3]
    type = ZapdosEEDFRateConstant
    property_file = &#x27;Argon_reactions_paper_RateCoefficients/ar_excited_ionization.txt&#x27;
    reaction = &#x27;em + Ar* -&gt; em + em + Ar+&#x27;
    mean_energy = mean_en
    electrons = em
  []
  [reaction_4]
    type = GenericRateConstant
    reaction = &#x27;em + Ar* -&gt; em + Ar_r&#x27;
    #reaction_rate_value = 2e-13
    reaction_rate_value = 1.2044e11
  []
  [reaction_5]
    type = GenericRateConstant
    reaction = &#x27;Ar* + Ar* -&gt; Ar+ + Ar + em&#x27;
    #reaction_rate_value = 6.2e-16
    reaction_rate_value = 373364000
  []
  [reaction_6]
    type = GenericRateConstant
    reaction = &#x27;Ar* + Ar -&gt; Ar + Ar&#x27;
    #reaction_rate_value = 3e-21
    reaction_rate_value = 1806.6
  []
  [reaction_7]
    type = GenericRateConstant
    reaction = &#x27;Ar* + Ar + Ar -&gt; Ar_2 + Ar&#x27;
    #reaction_rate_value = 1.1e-42
    reaction_rate_value = 398909.324
  []
[]

#New postprocessor that calculates the inverse of the plasma frequency
[Postprocessors]
  [InversePlasmaFreq]
    type = PlasmaFrequencyInverse
    variable = em
    use_moles = true
    execute_on = &#x27;INITIAL TIMESTEP_BEGIN&#x27;
  []
[]

[Preconditioning]
  active = &#x27;smp&#x27;
  [smp]
    type = SMP
    full = true
  []

  [fdp]
    type = FDP
    full = true
  []
[]

[Executioner]
  type = Transient
  end_time = 7.4e-3
  automatic_scaling = true
  dtmax = 1e-9
  petsc_options = &#x27;-snes_converged_reason -snes_linesearch_monitor&#x27;
  solve_type = NEWTON
  petsc_options_iname = &#x27;-pc_type -pc_factor_shift_type -pc_factor_shift_amount -ksp_type -snes_linesearch_minlambda&#x27;
  petsc_options_value = &#x27;lu NONZERO 1.e-10 fgmres 1e-3&#x27;
  nl_rel_tol = 1e-8
  #nl_abs_tol = 7.6e-5
  dtmin = 1e-14
  l_max_its = 20

  #Time steps based on the inverse of the plasma frequency
  #[TimeSteppers]
  #  [Postprocessor]
  #    type = PostprocessorDT
  #    postprocessor = InversePlasmaFreq
  #    scale = 0.1
  #  []
  #[]
[]

[Outputs]
  perf_graph = true
  [out]
    type = Exodus
  []
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></div><div class="col hide-on-med-and-down l2"><div class="toc-wrapper pin-top"><ul class="section table-of-contents"><li><a href="#9edc24a5-5fda-4f67-a3a6-fdb49b2cb02b" class="tooltipped" data-position="left" data-tooltip="Overview">Overview</a></li><li><a href="#5cea46d1-7bcb-4e35-b555-0b1ebf852c37" class="tooltipped" data-position="left" data-tooltip="Example Input File Syntax">Example Input File Syntax</a></li><li><a href="#31af10a4-f7f6-4116-809e-c71e1418b9bf" class="tooltipped" data-position="left" data-tooltip="Input Parameters">Input Parameters</a></li><li><a href="#3181a6b0-f663-4e80-a79e-755ae6826887" class="tooltipped" data-position="left" data-tooltip="Input Files">Input Files</a></li><li><a href="#05c996b4-89d8-46e0-8be4-7f0bcef9799f" class="tooltipped" data-position="left" data-tooltip="References">References</a></li></ul></div></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="../../contrib/fuse/fuse.min.js"></script><script type="text/javascript" src="../../js/search_index.js"></script><script type="text/javascript" src="../../js/sqa_moose.js"></script><script type="text/javascript" src="../../js/moose_input_parser.js"></script>